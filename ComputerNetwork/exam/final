------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[1] Transport Layer의 Process-to-Process 전송이 어떤 의미인지 설명합니다.

전송 계층은 [프로세스 간 전달, 즉 메시지의 일부인 패킷을 한 프로세스에서 다른 프로세스로 전달하는 역할]을 담당합니다.
두 프로세스는 클라이언트/서버 관계로 통신한다. 해당 통신에서는 socket으로 통신하며 socket은 ip + port로 구성되어 있다.

node-to-node        : data-link
Host-to-Host        : Network-link
Process-to-Process  : Transport-link

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[2] TCP/UDP의 헤더 정보에서 Process-to-Process 전송이 가능하게 하는 필드는 무엇이고, 어떤 용도로 사용하는지 설명합니다.

"Port Number"로써 TCP에서 제공되는 ip헤더와 tcp헤더를 통해서 tcp/socket 통신을 진행한다. 
TCP 헤더와 UDP 헤더에는 송신 프로세스를 나타내는 출발지 포트 번호와 수신 프로세스를 나타내는 목적지 포트 번호가 있다.
ip는 host의 주소를 찾는 변수이다.
이후 주소값에 들어간 Transport 정보는 Port 번호를 통해서 프로세스를 선택하여 어떤 프로세스에 들어갈 지 정하여 들어간다.
호스트 내에서 다수의 프로세스가 존재하며 네트워크를 사용한다. Port 번호를 통해 어떤 프로세스로 데이터를 전달해야 하는지를 식별할 수 있으므로, Process-to-Process 전송이 가능하다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[3] OSI 2계층에서 에러 검출 및 복구를 하지만, 4계층에서도 에러 검출 및 복구를 해야하는 이유를 설명합니다.

통신은 아무리 잘 전달되어 에러가 언제 어디서나 있다고 하는게 옳으며, 이를 미리 계산해서 통신 계층안에서의 안정성을 확보해야 한다.
주로 세그먼트의 전송과 관련된 에러 검출 및 복구를 수행합니다. 

2. **4계층에서의 에러 검출 및 복구:**
   - **역할:** 전송 계층은 송신 호스트와 수신 호스트 간의 신뢰성 있는 데이터 전송을 담당하며, 세그먼트의 전송, 흐름 제어, 오류 검출, 복구 등을 수행합니다.
   - **이유:** 데이터의 전송 중에는 네트워크의 혼잡, 패킷 손실, 네트워크 장애 등 다양한 이유로 에러가 발생할 수 있습니다. 이러한 에러는 주로 2계층에서는 처리하기 어렵고, 전송 계층에서 보다 효과적으로 처리할 수 있습니다. 에러를 더 높은 계층에서 처리함으로써 네트워크 전체의 효율성과 신뢰성을 높일 수 있습니다.

4계층에서는 전송 중에 발생하는 네트워크 상의 이슈로 인한 에러를 처리하여 신뢰성 있는 데이터 전송을 보장합니다. 각 계층의 역할과 책임에 따라 에러 검출 및 복구가 분리되어 수행되는 것이 효과적입니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[4] UDP는 에러 검출 및 복구를 하지 않지만, 그럼에도 불구하고 사용을 하는 이유를 설명합니다.

UDP(User Datagram Protocol)는 전송 계층의 프로토콜 중 하나로, 에러 검출 및 복구 기능을 제공하지 않습니다. 
UDP는 경량 프로토콜로서 단순한 헤더 구조와 연결 설정 없이 데이터를 전송합니다. 

연결 X 전달 / 흐름 제어 및 window mechanism이 없음 / UDP 프로토콜은 캡슐화 및 비캡슐화를 진행한다.

1. **낮은 오버헤드:**
- UDP 헤더가 간단하며, 연결 설정 및 에러 복구를 위한 추가적인 프로토콜이 없기 때문에 전체적인 오버헤드가 작습니다. 이로 인해 UDP는 빠른 속도와 낮은 지연을 제공합니다.

2. **빠른 전송 속도:**
- 에러 복구 메커니즘이 없기 때문에 별도의 확인(acknowledgment)을 기다리지 않습니다. 따라서 데이터를 전송하는 속도가 빠르며, 실시간 응용 프로그램이나 스트리밍 서비스에서 선호됩니다.

3. **간편한 구현:**
- UDP는 구현이 간단하고 가벼워서 개발이 쉽습니다. 더 많은 제어와 기능이 필요하지 않는 경우, 예를 들어 음성 통화나 동영상 스트리밍에서는 UDP가 더 적합할 수 있습니다.

4. **비연결성:**
- UDP는 연결 설정이 없고 비연결성이라는 특징을 가지고 있습니다. 이는 상태를 유지하지 않기 때문에 서버에 대한 추가적인 부하가 발생하지 않습니다.

5. **간단한 응용 분야:**
- 에러가 발생해도 복구할 필요가 없는 응용 분야에서 사용됩니다. 예를 들어 DNS(Domain Name System) 쿼리, NTP(Network Time Protocol) 등은 데이터의 손실이나 에러가 큰 문제가 되지 않는 경우가 많습니다.

UDP는 데이터를 안정적으로 전송하고자 하는 환경에서는 적합하지 않지만, 속도와 간소화가 중요한 상황에서는 매우 유용합니다. 
선택적으로 에러 처리 및 복구가 필요 없는 경우에는 UDP를 사용하여 성능을 향상시킬 수 있습니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[5] TCP의 에러 검출과 복구 동작을 TCP의 헤더 필드를 사용하여 설명합니다.


TCP의 에러 검출과 복구 동작은 주로 다양한 헤더 필드와 플래그를 사용하여 구현됩니다. 아래에서는 TCP의 헤더 필드를 중심으로하여 에러 검출과 복구 동작을 설명합니다.

1. **Checksum (체크섬):**
   - TCP 헤더에는 16비트 체크섬 필드가 있습니다. 이 필드는 TCP 세그먼트의 오류를 검출하는 데 사용됩니다.
   - 송신 측은 TCP 세그먼트를 전송하기 전에 데이터와 헤더에 대한 체크섬을 계산하고 이 값을 체크섬 필드에 포함시킵니다.
   - 수신 측은 받은 세그먼트에 대해 체크섬을 다시 계산하고, 송신 측의 체크섬과 비교하여 오류를 검출합니다.
   - 체크섬이 일치하지 않으면 수신 측은 오류로 판단하고 해당 세그먼트를 폐기합니다.

2. **Acknowledgment Number (확인 번호) 및 Retransmission (재전송):**
   - 수신 측은 올바르게 수신된 데이터에 대한 확인을 송신 측에게 알리기 위해 확인 번호를 사용합니다.
   - 송신 측은 일정 시간 내에 확인을 받지 못하면 해당 데이터가 손실되었다고 판단하고, 해당 데이터를 재전송합니다.

3. **Window Size (윈도우 크기):**
   - 윈도우 크기 필드는 TCP 세그먼트 헤더에 포함되어 있습니다. 이는 수신 측이 현재 받을 수 있는 데이터의 양을 나타냅니다.
   - 수신 측은 윈도우 크기를 조절하여 송신 측에게 데이터를 얼마나 많이 전송할 수 있는지 알려줍니다.
   - 효과적인 흐름 제어를 통해 데이터의 오버플로우를 방지하고, 복구 시간을 최소화합니다.

4. **Selective Acknowledgment (선택적 확인) 및 SACK 옵션:**
   - SACK 옵션을 사용하여 수신 측은 어떤 데이터가 손상되었는지를 세밀하게 알려줄 수 있습니다.
   - 송신 측은 SACK 옵션을 통해 전송이 실패한 부분에 대한 재전송을 수행할 수 있습니다.

5. **Retransmission Timeout (재전송 시간 초과):**
   - TCP은 재전송 타이머를 사용하여 수신 측으로부터 일정 시간 내에 확인을 받지 못한 경우 해당 데이터를 재전송합니다.
   - 재전송 타이머를 조절하여 네트워크 상황에 적응하며, 성능을 최적화합니다.

TCP의 헤더 필드와 동작을 조합하여, 송신 측과 수신 측 간의 신뢰성 있는 통신이 가능하도록 에러 검출과 복구 메커니즘이 구현됩니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[6] TCP의 흐름 제어 동작을 TCP의 헤더 필드를 사용하여 설명합니다.

TCP의 흐름 제어는 수신 측이 송신 측에게 데이터의 흐름을 적절하게 조절하도록 하는 메커니즘입니다. 이러한 동작은 TCP 헤더의 여러 필드를 통해 이뤄지며, 주요한 헤더 필드와 동작을 설명합니다.

1. **Sequence Number (순서 번호):**
   - TCP 세그먼트의 헤더에는 데이터의 순서 번호가 포함됩니다.
   - 수신 측은 이 순서 번호를 사용하여 송신 측으로부터 수신한 데이터의 순서를 파악합니다.
   - 순서 번호를 통해 수신 측은 송신 측에게 어떤 데이터가 수신되었는지 알립니다.

2. **Acknowledgment Number (확인 번호):**
   - 수신 측은 확인 번호를 사용하여 송신 측에게 성공적으로 수신했다는 사실을 알립니다.
   - 수신 측은 확인 번호로 송신 측에게 다음에 기대되는 데이터의 순서를 알려줍니다.
   - 이를 통해 송신 측은 수신 측의 상태를 파악하고 데이터의 흐름을 조절합니다.

3. **Window Size (윈도우 크기):**
   - TCP 헤더에는 16비트로 표현되는 윈도우 크기 필드가 있습니다.
   - 윈도우 크기는 수신 측이 현재 받을 수 있는 데이터의 양을 나타냅니다.
   - 송신 측은 이 윈도우 크기를 고려하여 데이터를 전송하며, 수신 측은 이를 조절하여 흐름을 제어합니다.

4. **Flow Control Process (흐름 제어 프로세스):**
   - 송신 측이 데이터를 전송할 때, 수신 측은 윈도우 크기를 통해 얼마나 많은 데이터를 받을 수 있는지 알려줍니다.
   - 수신 측의 윈도우 크기를 고려하여 송신 측은 특정 시점에 보낼 수 있는 데이터의 양을 조절합니다.
   - 이로써 수신 측은 과부하를 방지하고 자신의 수신 속도에 맞게 데이터를 수용할 수 있습니다.

이러한 헤더 필드와 동작을 통해 TCP는 흐름 제어를 수행하여 송수신 간의 데이터 전송을 효율적으로 관리합니다. Flow control은 네트워크 혼잡을 방지하고 안정적인 통신을 제공하는데 기여합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[7] TCP의 혼잡 제어 동작을 TCP의 cwnd 값을 관리하는 2가지 방식을 사용하여 설명합니다.


TCP의 혼잡 제어(Congestion Control)는 네트워크 혼잡을 효과적으로 관리하여 성능을 최적화하는 데 중요한 역할을 합니다. 혼잡 제어는 TCP의 윈도우 크기를 동적으로 조절하여 네트워크의 혼잡 상태에 대응합니다. 윈도우 크기는 cwnd(혼잡 윈도우)라는 변수를 통해 관리되며, 이 값은 두 가지 방식을 사용하여 조절됩니다.

1. **AIMD (Additive Increase, Multiplicative Decrease):**
   - **증가 (Additive Increase):** TCP는 혼잡이 발생하지 않을 때, 일정한 주기(라운드 트립 타임)마다 cwnd를 1씩 증가시킵니다. 이것이 증가라는 용어의 유래입니다. 이는 네트워크의 이용 가능한 대역폭을 효과적으로 활용하는 방법입니다.
   - **감소 (Multiplicative Decrease):** 혼잡이 발생하면, 즉 패킷 손실이 감지되면 TCP는 cwnd를 반으로 줄입니다. 이는 혼잡을 감지했으므로 네트워크의 용량을 줄이고 다시 적응하는 것입니다.

2. **Slow Start:**
   - 초기에는 빠르게 증가시키는 방식으로 동작합니다. 연결이 시작될 때, cwnd는 1부터 시작하고, 매번 성공적으로 패킷이 전송될 때마다 cwnd를 두 배씩 증가시킵니다. 이는 네트워크의 초기 상태에서 가능한 한 빠르게 대역폭을 활용하기 위한 것입니다.
   - 단, Slow Start는 cwnd가 어떤 임계값(threshold)까지만 증가하면 AIMD로 전환됩니다. 이후에는 AIMD 방식으로 윈도우 크기를 관리하게 됩니다.

이러한 방식들을 조합하여 TCP는 네트워크 혼잡에 유연하게 대응하며, 최적의 성능을 유지하려고 노력합니다. AIMD와 Slow Start은 TCP의 혼잡 제어 동작을 설명하는 핵심 개념 중 일부입니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[8] Socket 프로그래밍에서 서버와 클라이언트의 동작 절차를 주요 함수 기준으로 설명합니다.

client                  server
---------------------------------
socket                  socket   |                                  1) 첫 번째 단계는 소켓을 생성하는 단계
  |                       |      |
  |                      bind    | open listen                      2) 서버가 사용할 ip주소와 port 번호를 결합
  |                       |      |
  |                     listen   |                                  3) client로부터 요청이 수신되는지 확인
  |    connect request    |
connect ------------->    |                                         4) ip주소와 포트번호로 식별되는 대상에게 연결 요청을 보낸다. / block 방식(결과가 결정되기 전까지는 connect() 실행 안끝남)
                        accept                                      5) 데이터 통신을 위한 소켓을 생성한다.
---------------------------------
| write                   read  | client server
| read                    write |    session                        6)  send()와 recv()로 데이터 교환 
---------------------------------
  |                        |
close                     read
                           |
                          close                                     7) 소켓을 닫게됨


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[9] 사용자의 URL 입력 이후 부터, HTTP Req가 HTTP Client에서 전송되기 전에 이뤄져야 하는 동작을 차례대로 설명합니다. (DNS Lookup, TCP 연결 설정)

오리지널 HTTP 1.1의 동작 방식이다.
1. url창을 입력함 (도메인 이름+port 이름(통상적으로 80을 입력함))
2. 웹브라우져는 DNS(Domain Name System) 작업을 통해 호스트 이름을 ip address로 바꿈.
3. 이후에 tcp 연결을 진행
  3-1. ip + port의 주소에 접근
  3-2. HTTP GET request 진행
  3-3. HTTP를 서버로 부터 읽는다.
  3-4. 3-1에서 연결된 connection을 끊는다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[10] HTTP의 4대 메시지를 나열하고, 각각의 기능, 그리고 각각에 대해서 REQ/RES에 포함하는 정보가 무엇인지 설명합니다.

GET: 
  request   : 주소/프로토콜(+버전)/Host 주소/받을 수 있는 정보
  response  : 프로토콜(+버전)/status code/context 타입/길이
PUT(파일을 업로드):
  request   : 파일위치(호스트 주소 아래에 있는)/프로토콜(버전)/Host 주소/content 타입/컨텐츠 길이/
  response  : 프토토콜(버전)/status code/저장된 위치(기본적으로 root)/content 타입/컨텐츠 길이
POST(정보 전달):
  request   : ?/프토토콜(버전)/호스트주소/컨텐츠 타입/컨텐츠 길이
  response  : 프로토콜(버전)/컨텐츠 타입/컨텐츠 길이
DELETE
  request   : 파일위치(target)/프로토콜(버전)/호스트 주소
  response  : 프로토콜(버전)/컨텐츠 타입/컨텐츠 길이

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[11] HTTP/2의 다중화 기술은 HTTP/1.1과 어떤 점이 다르며, 어떻게 다중화가 가능한지 설명합니다.

HTTP/2는 HTTP/1.1과 비교하여 다중화(Multiplexing) 기술에서 큰 개선을 제공합니다. 다중화는 여러 개의 요청과 응답을 동시에 처리하여 효율성을 향상시키는 메커니즘입니다. 아래는 HTTP/2에서의 다중화와 HTTP/1.1과의 차이점에 대한 설명입니다.

### HTTP/1.1과의 차이점:

1. **Connection 개수:**
   - **HTTP/1.1:** 하나의 TCP 연결에서 한 번에 하나의 요청만 처리 가능합니다. 여러 개의 리소스를 가져오려면 복수의 연결이 필요했습니다.
   - **HTTP/2:** 단일 TCP 연결을 통해 여러 요청과 응답을 동시에 처리할 수 있습니다. 다중화는 여러 스트림을 하나의 연결에서 동시에 처리할 수 있도록 합니다.

2. **Head-of-Line Blocking 문제:**
   - **HTTP/1.1:** 한 번에 하나의 요청만 처리 가능하기 때문에 하나의 요청이 지연되면 그 이후의 요청도 기다려야 하는 Head-of-Line Blocking 문제가 발생할 수 있습니다.
   - **HTTP/2:** 다중화를 통해 다양한 요청과 응답이 병렬적으로 전송되기 때문에 하나의 요청이 지연되어도 다른 요청은 계속 처리됩니다.

3. **Header 압축:**
   - **HTTP/1.1:** 각 요청과 응답에는 중복되는 헤더 정보가 계속 전송되어 대역폭 낭비가 발생할 수 있습니다.
   - **HTTP/2:** 헤더 필드는 허프만 코딩 기반의 HPACK 압축 알고리즘을 사용하여 압축되어 전송되어 대역폭을 절약합니다.

### 다중화의 동작 방식:

1. **스트림 (Stream):**
   - HTTP/2에서 다중화는 여러 개의 독립적인 스트림을 통해 이뤄집니다. 각 스트림은 요청이나 응답을 나타냅니다.

2. **스트림 식별자 (Stream Identifier):**
   - 각 스트림은 고유한 스트림 식별자를 가지며, 이를 통해 어떤 요청과 응답이 어떤 스트림에 속하는지 식별합니다.

3. **프레임 (Frame):**
   - 다중화는 여러 개의 프레임을 하나의 TCP 연결을 통해 동시에 전송합니다. 각 프레임은 특정 스트림에 속하는 데이터의 조각을 나타냅니다.

4. **우선순위 부여:**
   - HTTP/2는 각 스트림에 대해 우선순위를 부여할 수 있습니다. 서버와 클라이언트는 중요한 요청에 대해 더 높은 우선순위를 부여하여 특정 요청이 먼저 처리되도록 할 수 있습니다.

HTTP/2의 다중화 기술은 이러한 방식으로 동작하여 여러 요청과 응답을 효율적으로 처리하고 성능을 향상시킵니다. 이는 특히 웹 페이지 로딩 속도를 높이고, 더 효율적으로 리소스를 활용할 수 있도록 도와줍니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[12] HTTP/2에서 HTTP Req/Res 메시지를 어떻게 압축하는지 설명합니다.

HTTP/2에서는 헤더 필드의 압축이 중요한 부분 중 하나입니다. 헤더 필드는 HTTP 요청과 응답 메시지의 메타데이터를 전송하는 데 사용되며, 중복되는 헤더를 효과적으로 압축하여 대역폭을 절약하는 것이 목표입니다. HTTP/2에서는 HPACK이라는 헤더 압축 알고리즘이 사용됩니다.

HPACK 알고리즘:
헤더 필드 색인화 (Header Field Indexing):

헤더 필드의 이름과 값은 정적 테이블과 동적 테이블에 색인됩니다. 정적 테이블에는 일반적인 헤더 필드가 미리 정의되어 있고, 동적 테이블은 실시간으로 추가되는 헤더 필드를 저장합니다.
리터럴 헤더 필드와 인덱스 색인화 (Literal Header Field with Indexing):

새로운 헤더 필드가 추가될 때, 해당 헤더 필드의 이름과 값이 동적 테이블에 추가됩니다. 이때, 색인 번호를 할당하고, 나중에 동일한 헤더 필드가 추가될 때는 해당 인덱스를 사용하여 중복을 피합니다.
리터럴 헤더 필드 색인화 (Literal Header Field without Indexing):

동적 테이블에 색인을 추가하지 않고 리터럴 헤더 필드를 추가합니다. 이 경우, 중복이 발생해도 이를 테이블에 저장하지 않기 때문에 다음에도 동일한 헤더가 나오면 중복으로 인해 발생하는 오버헤드를 줄일 수 있습니다.
리터럴 헤더 필드 색인화 (Literal Header Field never Indexed):

리터럴 헤더 필드를 추가하면서 해당 필드를 동적 테이블에 색인 추가 없이 전송합니다. 이는 중복을 제거하지만, 나중에 같은 헤더가 다시 나올 때까지 해당 헤더를 색인에 추가하지 않습니다.


















------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[13] HTTP/3는 HTTP/2가 (TCP를 사용하기 때문에 해결하지 못하는) 어떤 문제점을 해결하고 있는지, 네트워크에서의 에러 발생과 초기 연결 관점에서 설명합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[14] SIP 프로토콜을 사용하여 음성 전화를 하는 경우, 발신자와 착신자 간의 연결 설정과 해제 과정을 주요 메시지를 사용하여 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[15] WebRTC에서 STUN 서버와 TURN 서버의 역할에 대해서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[16] Cloud Computing이 시작하게된 계기를 Public Cloud 사업자와 사업을 시작하는 벤처 회사 입장에서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[17] Public Computing의 3대 모델을 나열하고, 각각 어떤 사항을 제공하는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[18] EC2와 S3가 무엇인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[20] Virtual Machine 기반의 Computing의 Guest OS over Host OS이 문제로 작용한 사용자는 누구이며, 왜 문제인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[21] Container 기술이 Guest OS over Host OS 문제를 해결할 수 있는 이유와, Container에 포함되는 내용물은 무엇인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[22] Microservice 개념에 의해서 만들어지는 프로그래밍(들)이 과거 하나의 강력한 프로그램으로 만드는 경우 대비 가질수 있는 장점들을 기술적/비기술적인 측면에서 설명해 봅니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ㅇㅌㅌ
[23] Game 서버 중, Master Server와 Game (Logic) Server의 역할에 대해서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[24] Game 서버가 제공하는 실시간 성 서비스는 어떤 것들이 있는지 설명합니다. (네트워크 기능, 콘텐츠 생성 기능 등 측면을 강의노트의 서버 예제들을 참조하여 답변함)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------