------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[1] Transport Layer의 Process-to-Process 전송이 어떤 의미인지 설명합니다.

Transport Layer는 컴퓨터 네트워크에서 데이터를 종단 시스템 간에 안전하게 전송하기 위한 책임을 지는 계층입니다.
이 계층은 송신 호스트에서 수신 호스트로 데이터를 전달하고, 종단 시스템 간의 신뢰성 있는 통신을 제공합니다. 
"Process-to-Process" 전송은 Transport Layer가 데이터를 송신 프로세스에서 수신 프로세스로 전송하는 것을 의미합니다.
여기서 "프로세스"는 컴퓨터 시스템에서 실행 중인 프로그램을 나타냅니다. 
각 프로그램은 프로세스로 실행되며, 이러한 프로세스들 간에는 데이터를 주고받아야 하는 경우가 많습니다. 
Transport Layer는 이러한 프로세스 간의 통신을 관리하고 데이터를 안전하게 전달하는 역할을 합니다.
프로세스 간 통신은 일반적으로 송신 프로세스에서 생성된 데이터를 수신 프로세스로 전송하는 것을 의미합니다. 
Transport Layer는 데이터의 분할, 전송 중 오류 검출 및 복구, 흐름 제어 등을 담당하여 데이터가 안전하게 전송되도록 보장합니다. 
이러한 프로세스 간 전송은 종단 시스템 간의 효과적인 통신을 가능케 하며, 프로세스 간의 상호 작용을 지원합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[2] TCP/UDP의 헤더 정보에서 Process-to-Process 전송이 가능하게 하는 필드는 무엇이고, 어떤 용도로 사용하는지 설명합니다.

TCP (Transmission Control Protocol)와 UDP (User Datagram Protocol)는 Transport Layer에서 사용되는 프로토콜로, 이들은 각각 프로세스 간 통신을 제공하는데 사용되는 헤더를 가지고 있습니다.
TCP의 헤더 정보 중에서 Process-to-Process 전송을 가능하게 하는 필드는 "Port Number"입니다. 
TCP 헤더에는 출발지 포트 번호(Source Port)와 목적지 포트 번호(Destination Port)가 있습니다. 
포트 번호는 16비트 크기로, 각각 송신 프로세스와 수신 프로세스를 식별합니다.
UDP 또한 포트 번호를 사용하여 프로세스 간 통신을 식별합니다.
UDP 헤더에는 송신 프로세스를 나타내는 출발지 포트 번호와 수신 프로세스를 나타내는 목적지 포트 번호가 있습니다.
포트 번호는 운영 체제에서 관리하는 로컬 포트(Local Port)와 네트워크 상에서 사용되는 원격 포트(Remote Port)로 나뉩니다. 
송신 호스트는 로컬 포트를, 수신 호스트는 원격 포트를 통해 프로세스 간 통신을 이룹니다.
이러한 포트 번호를 사용함으로써 TCP와 UDP는 여러 프로세스 간에 동시에 통신이 이루어질 수 있고, 호스트 내에서 다수의 프로세스가 동시에 네트워크를 사용할 수 있습니다.
Port 번호를 통해 어떤 프로세스로 데이터를 전달해야 하는지를 식별할 수 있으므로, Process-to-Process 전송이 가능해집니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[3] OSI 2계층에서 에러 검출 및 복구를 하지만, 4계층에서도 에러 검출 및 복구를 해야하는 이유를 설명합니다.

통신은 아무리 잘 전달되어 에러가 있다고 하는게 옳으며, 통신 계층안에서의 안정성을 확보해야 한다.
OSI (Open Systems Interconnection) 모델에서 2계층은 데이터 링크 계층으로, 주로 프레임의 전송과 관련된 에러 검출 및 복구를 수행합니다. 
반면에 4계층은 전송 계층으로, 주로 세그먼트의 전송과 관련된 에러 검출 및 복구를 수행합니다. 
각 계층이 에러 검출 및 복구를 수행하는 이유는 그 계층에서의 역할과 책임이 다르기 때문입니다.

1. **2계층에서의 에러 검출 및 복구:**
   - **역할:** 데이터 링크 계층은 물리적인 매체를 통해 프레임을 안전하게 전송하고, 주로 이동 중에 발생하는 비트 에러를 검출하고 수정합니다.
   - **이유:** 물리적인 매체에서 발생하는 노이즈, 왜곡, 간섭 등으로 인해 데이터 손상이 발생할 수 있습니다. 이러한 손상을 2계층에서 검출하고 복구함으로써 상위 계층에 신뢰성 있는 데이터를 전달합니다.

2. **4계층에서의 에러 검출 및 복구:**
   - **역할:** 전송 계층은 송신 호스트와 수신 호스트 간의 신뢰성 있는 데이터 전송을 담당하며, 세그먼트의 전송, 흐름 제어, 오류 검출, 복구 등을 수행합니다.
   - **이유:** 데이터의 전송 중에는 네트워크의 혼잡, 패킷 손실, 네트워크 장애 등 다양한 이유로 에러가 발생할 수 있습니다. 이러한 에러는 주로 2계층에서는 처리하기 어렵고, 전송 계층에서 보다 효과적으로 처리할 수 있습니다. 에러를 더 높은 계층에서 처리함으로써 네트워크 전체의 효율성과 신뢰성을 높일 수 있습니다.

간단히 말하면, 2계층에서는 물리적인 매체로 인한 비트 에러를 검출하고 복구하며, 4계층에서는 전송 중에 발생하는 네트워크 상의 이슈로 인한 에러를 처리하여 신뢰성 있는 데이터 전송을 보장합니다. 각 계층의 역할과 책임에 따라 에러 검출 및 복구가 분리되어 수행되는 것이 효과적입니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[4] UDP는 에러 검출 및 복구를 하지 않지만, 그럼에도 불구하고 사용을 하는 이유를 설명합니다.

UDP(User Datagram Protocol)는 전송 계층의 프로토콜 중 하나로, 에러 검출 및 복구 기능을 제공하지 않습니다. 
UDP는 경량 프로토콜로서 단순한 헤더 구조와 연결 설정 없이 데이터를 전송합니다. UDP를 사용하는 이유는 다음과 같습니다:

연결 X 전달 / 흐름 제어 및 window mechanism이 없음 / UDP 프로토콜은 캡슐화 및 비캡슐화를 진행한다.


1. **낮은 오버헤드:**
- UDP 헤더가 간단하며, 연결 설정 및 에러 복구를 위한 추가적인 프로토콜이 없기 때문에 전체적인 오버헤드가 작습니다. 이로 인해 UDP는 빠른 속도와 낮은 지연을 제공합니다.

2. **빠른 전송 속도:**
- 에러 복구 메커니즘이 없기 때문에 별도의 확인(acknowledgment)을 기다리지 않습니다. 따라서 데이터를 전송하는 속도가 빠르며, 실시간 응용 프로그램이나 스트리밍 서비스에서 선호됩니다.

3. **간편한 구현:**
- UDP는 구현이 간단하고 가벼워서 개발이 쉽습니다. 더 많은 제어와 기능이 필요하지 않는 경우, 예를 들어 음성 통화나 동영상 스트리밍에서는 UDP가 더 적합할 수 있습니다.

4. **비연결성:**
- UDP는 연결 설정이 없고 비연결성이라는 특징을 가지고 있습니다. 이는 상태를 유지하지 않기 때문에 서버에 대한 추가적인 부하가 발생하지 않습니다.

5. **간단한 응용 분야:**
- 에러가 발생해도 복구할 필요가 없는 응용 분야에서 사용됩니다. 예를 들어 DNS(Domain Name System) 쿼리, NTP(Network Time Protocol) 등은 데이터의 손실이나 에러가 큰 문제가 되지 않는 경우가 많습니다.

UDP는 데이터를 안정적으로 전송하고자 하는 환경에서는 적합하지 않지만, 속도와 간소화가 중요한 상황에서는 매우 유용합니다. 
선택적으로 에러 처리 및 복구가 필요 없는 경우에는 UDP를 사용하여 성능을 향상시킬 수 있습니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[5] TCP의 에러 검출과 복구 동작을 TCP의 헤더 필드를 사용하여 설명합니다.


Ack전달을 기반으로 에러 검출을 한다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[6] TCP의 흐름 제어 동작을 TCP의 헤더 필드를 사용하여 설명합니다.





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[7] TCP의 혼잡 제어 동작을 TCP의 cwnd 값을 관리하는 2가지 방식을 사용하여 설명합니다.






------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[8] Socket 프로그래밍에서 서버와 클라이언트의 동작 절차를 주요 함수 기준으로 설명합니다.

client                  server
---------------------------------
socket                  socket   |                                  1) 첫 번째 단계는 소켓을 생성하는 단계
  |                       |      |
  |                      bind    | open listen                      2) 서버가 사용할 ip주소와 port 번호를 결합
  |                       |      |
  |                     listen   |                                  3) client로부터 요청이 수신되는지 확인
  |    connect request    |
connect ------------->    |                                         4) ip주소와 포트번호로 식별되는 대상에게 연결 요청을 보낸다. / block 방식(결과가 결정되기 전까지는 connect() 실행 안끝남)
                        accept                                      5) 데이터 통신을 위한 소켓을 생성한다.
---------------------------------
| write                   read  | client server
| read                    write |    session                        6)  send()와 recv()로 데이터 교환 
---------------------------------
  |                        |
close                     read
                           |
                          close                                     7) 소켓을 닫게됨


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[9] 사용자의 URL 입력 이후 부터, HTTP Req가 HTTP Client에서 전송되기 전에 이뤄져야 하는 동작을 차례대로 설명합니다. (DNS Lookup, TCP 연결 설정)






------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[10] HTTP의 4대 메시지를 나열하고, 각각의 기능, 그리고 각각에 대해서 REQ/RES에 포함하는 정보가 무엇인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[11] HTTP/2의 다중화 기술은 HTTP/1.1과 어떤 점이 다르며, 어떻게 다중화가 가능한지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[12] HTTP/2에서 HTTP Req/Res 메시지를 어떻게 압축하는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[13] HTTP/3는 HTTP/2가 (TCP를 사용하기 때문에 해결하지 못하는) 어떤 문제점을 해결하고 있는지, 네트워크에서의 에러 발생과 초기 연결 관점에서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[14] SIP 프로토콜을 사용하여 음성 전화를 하는 경우, 발신자와 착신자 간의 연결 설정과 해제 과정을 주요 메시지를 사용하여 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[15] WebRTC에서 STUN 서버와 TURN 서버의 역할에 대해서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[16] Cloud Computing이 시작하게된 계기를 Public Cloud 사업자와 사업을 시작하는 벤처 회사 입장에서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[17] Public Computing의 3대 모델을 나열하고, 각각 어떤 사항을 제공하는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[18] EC2와 S3가 무엇인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[20] Virtual Machine 기반의 Computing의 Guest OS over Host OS이 문제로 작용한 사용자는 누구이며, 왜 문제인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[21] Container 기술이 Guest OS over Host OS 문제를 해결할 수 있는 이유와, Container에 포함되는 내용물은 무엇인지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[22] Microservice 개념에 의해서 만들어지는 프로그래밍(들)이 과거 하나의 강력한 프로그램으로 만드는 경우 대비 가질수 있는 장점들을 기술적/비기술적인 측면에서 설명해 봅니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------