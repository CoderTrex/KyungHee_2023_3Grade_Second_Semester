------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------ [1] Transport Layer의 Process-to-Process 전송이 어떤 의미인지 설명합니다. ------------------

전송 계층은 [프로세스 간 전달, 즉 메시지의 일부인 패킷을 한 프로세스에서 다른 프로세스로 전달하는 역할]을 담당합니다.
두 프로세스는 클라이언트/서버 관계로 통신한다. 해당 통신에서는 socket으로 통신하며 socket은 ip + port로 구성되어 있다.


클라이언트  : 로컬 호스트의 프로세스
서버        : 원격 호스트에서 서비스를 제공하기 위한 프로세스이다.

Client/Server Paradigm
Process to Process Delivery에서 가장 흔히 사용되는 통신방법은 Client/Server paradigm이다.

client : 로컬 호스트에서의 프로세스
Server : 원격 호스트에서 서비스를 제공하는 프로세스
위 프로세스들은 모두 동일한 이름을 가진다. 두 프로세스간의 통신을 위해서는 Local host, Local Process, Remote Host, Remote Process를 알아야한다.

두 프로세스(클라이언트 및 서버) 모두 동일한 이름을 갖는다.
통신을 위해서는 다음을 정의해야 합니다.
   1. 로컬 호스트
   2. 로컬 프로세스
   3. 원격 호스트
   4. 원격 프로세스

Process-to-Process  : Transport-link
Host-to-Host        : Network-link
node-to-node        : data-link

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------ [2] TCP/UDP의 헤더 정보에서 Process-to-Process 전송이 가능하게 하는 필드는 무엇이고, 어떤 용도로 사용하는지 설명합니다. ------------------


"Port Number"로써 TCP에서 제공되는 ip헤더와 tcp헤더를 통해서 tcp/socket 통신을 진행한다.
TCP 헤더와 UDP 헤더에는 송신 프로세스를 나타내는 출발지 포트 번호와 수신 프로세스를 나타내는 목적지 포트 번호가 있다.
ip는 host의 주소를 찾는 변수이다.
이후 주소값에 들어간 Transport 정보는 Port 번호를 통해서 프로세스를 선택하여 어떤 프로세스에 들어갈 지 정하여 들어간다.
호스트 내에서 다수의 프로세스가 존재하며 네트워크를 사용한다. Port 번호를 통해 어떤 프로세스로 데이터를 전달해야 하는지를 식별할 수 있으므로, Process-to-Process 전송이 가능하다.

- tmi -
데이터 링크 계층에서 프레임은 도착지의 MAC 주소를 알아야한다
네트워크 계층에서는 IP주소를 알아야 한다
Transport 계층에서는 transport layer address(port number라 불리는, 호스트에서 실행중인 여러 프로세스들중 선택하게 하는) 것을 알아야 한다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------ [3] OSI 2계층에서 에러 검출 및 복구를 하지만, 4계층에서도 에러 검출 및 복구를 해야하는 이유를 설명합니다. ------------------

에러 처리에 대한 필요성에 대한 대답은 무조건 'yes'이다.
인터넷의 네트워크 계층은 신뢰할 수 없습니다(최선의 노력 전달). 전송 계층에서 안정성을 구현해야 합니다.

통신에 있어서 정보가 전달되는 과정에서 라우터 과정으로 돌아가는 데이터는 1,2 계층에서만 이동하는 것이 아닌, 3계층에서 데이터가 이동한다.
때문에 3계층에서 어떤 일이 일어날 지 모르기에 해아한다.

추가 정보
4계층에서의 에러 검출 및 복구:
   - 역할: 전송 계층은 송신 호스트와 수신 호스트 간의 신뢰성 있는 데이터 전송을 담당하며, 세그먼트의 전송, 흐름 제어, 오류 검출, 복구 등을 수행합니다.
            이러한 에러는 주로 2계층에서는 처리하기 어렵고, 전송 계층에서 보다 효과적으로 처리할 수 있습니다. 
            에러를 더 높은 계층에서 처리함으로써 네트워크 전체의 효율성과 신뢰성을 높일 수 있습니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------ [4] UDP는 에러 검출 및 복구를 하지 않지만, 그럼에도 불구하고 사용을 하는 이유를 설명합니다. ------------------

UDP는 connectionless, unreliable한 전송 프로토콜이다. 
IP 서비스에, host-to-host대신 process-to-process를 위한 정보를 추가하는 것을 제외하고, 어떠한 것도 더하지 않는다. 
UDP는 매우 간단한 프로토콜이며, 최소한의 부담을 준다.
즉 여러가지 flow control과 ERROR 검출 과정을 거치지 않기 때문에 속도가 빠르다. 
사용하는 이유는 기존의 tcp의 비해서 가볍고 빠르기 에러에 대한 부담이 적고, 전송되는 데이터의 사이즈가 작은 경우에는 사용가능하다.


- tmi -

UDP의 헤더에는 source port address, Destination port address, UDP total length 그리고 Checksum으로 구성되어 있고, Checksum으로만 보안인증을 진행함.
UDP는 독립덕인 데이터그램으로 연결없는 서비스를 제공한다.
flow control, ERROR 검출 및 윈도우 메커니즘(에러 검출 메커니즘)이 없다.
Encapsulation & Decapsulation을 통해서 메세지를 전달한다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
------------------ [5] TCP의 에러 검출과 복구 동작을 TCP의 헤더 필드를 사용하여 설명합니다. ------------------

ACK의 값을 데이터를 보내고 timer를 통해서 server에서 보낸 Ack를 확인하는 것이 가장 기본적이다.
만약 ack가 답을 받아야하는 특정 시간을 넘어가거나,
3번의 duplicate에도 해당 Data에 대한 ACK가 전달되지 않았다면 에러로 간주하고 다시 보낸다.
ack 사인 사라진 졌지만 이후의 ack의 큰 수가 온다면 이전 넘버는 온것으로 간주한다.


1. URG (Urgent):
   - 에러 검출 및 복구: URG 플래그는 긴급 데이터의 존재를 나타냅니다. 긴급 데이터는 전송 중에 높은 우선순위로 처리되어야 하는 데이터를 의미합니다. 에러 검출과 복구와 직접적인 관련은 없지만, 긴급 데이터의 존재를 알려 에러에 대한 조치를 취할 수 있습니다.
2. ACK (Acknowledgment):
   - 에러 검출 및 복구: ACK 플래그는 데이터의 정상적인 수신을 확인하는 데 사용됩니다. 에러가 발생하면 재전송이 요청될 수 있습니다. ACK 플래그는 데이터 손실을 검출하고 복구하는데 도움이 됩니다.
3. PSH (Push):
   - 에러 검출 및 복구: PSH 플래그는 데이터를 즉시 전송하라는 의미를 갖습니다. 데이터 전송에 대한 높은 우선순위를 갖기 때문에, 에러가 감지되면 해당 데이터를 빠르게 재전송하여 복구할 수 있습니다.
4. RST (Reset):
   - 에러 검출 및 복구: RST 플래그는 연결을 초기화하거나 문제가 발생했을 때 사용됩니다. 에러가 심각한 경우, 연결을 재설정하여 상태를 초기화하고 에러에 대한 조치를 취할 수 있습니다.
5. SYN (Synchronize):
   - 에러 검출 및 복구: SYN 플래그는 TCP 연결을 초기화하는데 사용됩니다. 에러가 없는 정상적인 연결 설정의 일부로 사용되며, 이 단계에서 에러가 발생하면 연결이 성립되지 않을 수 있습니다.
6. FIN (Finish):
   - 에러 검출 및 복구: FIN 플래그는 연결을 종료할 때 사용됩니다. 정상적인 연결 종료의 일부로 사용되며, 이 단계에서 에러가 발생하면 종료 과정이 중단될 수 있습니다.
이러한 플래그들은 TCP 헤더에 포함되어 있으며, 네트워크 통신에서 데이터 전송의 신뢰성과 에러 복구를 돕는데 중요한 역할을 합니다.

1. Checksum (체크섬):
   - TCP 헤더에는 16비트 체크섬 필드가 있습니다. 이 필드는 TCP 세그먼트의 오류를 검출하는 데 사용됩니다.
   - 송신 측은 TCP 세그먼트를 전송하기 전에 데이터와 헤더에 대한 체크섬을 계산하고 이 값을 체크섬 필드에 포함시킵니다.
   - 수신 측은 받은 세그먼트에 대해 체크섬을 다시 계산하고, 송신 측의 체크섬과 비교하여 오류를 검출합니다.
   - 체크섬이 일치하지 않으면 수신 측은 오류로 판단하고 해당 세그먼트를 폐기합니다.

2. Window Size (윈도우 크기):
   - 윈도우 크기 필드는 TCP 세그먼트 헤더에 포함되어 있습니다. 이는 수신 측이 현재 받을 수 있는 데이터의 양을 나타냅니다.
   - 수신 측은 윈도우 크기를 조절하여 송신 측에게 데이터를 얼마나 많이 전송할 수 있는지 알려줍니다.
   - 효과적인 흐름 제어를 통해 데이터의 오버플로우를 방지하고, 복구 시간을 최소화합니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------ [6] TCP의 흐름 제어 동작을 TCP의 헤더 필드를 사용하여 설명합니다. ------------------

흐름제어를 하기 위해서 가상회선방식을 사용하는데 이는 정보 전달의 논리적 경로를 배정하고 해당 방식대로 움직임 -> UDP는 아무렇게나 감.

1. 연결을 시작할 때 ACK와 SYN을 통해서 초기 연결을 설정한다.
   ACK: Acknowledgment(승인)의 약자로 요청을 확인했다는 응답을 뜻한다.
   SYN: Synchronize(동시에 발생하다) Sequence Number의 약자이다. 
         연결이 이루어지도록 요청하는 의미이다.
2. 데이터를 전달할 수 있음
   PSH: 밀어 넣기
      송신 사이트의 응용 프로그램은 송신 TCP가 창이 채워질 때까지 기다리지 않아야 하는 
      푸시 작업을 요청할 수 있습니다. 세그먼트를 생성하고 즉시 보내야 합니다.
   URG: 긴급 데이터
      송신 응용 프로그램이 수신 응용 프로그램에서 데이터의 일부를 순서 없이 읽도록 하려는 경우. 
      발신자는 URG 비트가 설정된 세그먼트를 보낼 수 있습니다. 
      수신 TCP는 URG 비트가 설정된 세그먼트를 수신하면 포인터 값을 사용하여 
      세그먼트에서 긴급 데이터를 추출하고 순서에 맞지 않게 수신 응용 프로그램에 전달합니다.
3. 연결 종료에는 FIN + ACK를 통해서 종료한다.


- 알아두면 좋은 기본 개념 -
Window Size (윈도우 크기):
   - TCP 헤더에는 16비트로 표현되는 윈도우 크기 필드가 있습니다.
   - 윈도우 크기는 수신 측이 현재 받을 수 있는 데이터의 양을 나타냅니다.
   - 송신 측은 이 윈도우 크기를 고려하여 데이터를 전송하며, 수신 측은 이를 조절하여 흐름을 제어합니다.

Flow Control Process (흐름 제어 프로세스):
   - 송신 측이 데이터를 전송할 때, 수신 측은 윈도우 크기를 통해 얼마나 많은 데이터를 받을 수 있는지 알려줍니다.
   - 수신 측의 윈도우 크기를 고려하여 송신 측은 특정 시점에 보낼 수 있는 데이터의 양을 조절합니다.
   - 이로써 수신 측은 과부하를 방지하고 자신의 수신 속도에 맞게 데이터를 수용할 수 있습니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[7] TCP의 혼잡 제어 동작을 TCP의 cwnd 값을 관리하는 2가지 방식을 사용하여 설명합니다.

1) Slow Start, exponential increase : cwnd값을 작은 값으로 시작하여 지수적으로 증가시키는 방식. 전송 속도를 빠르게 높일 수는 있으나 네트워크의 혼잡을 유발할 수 있다. 
2) Congestion avoidance, Additive increase : cwnd threshhold에 도달할 시 cwnd의값을 조금씩 증가시켜 안정적으로 전송속도를 조절하고 네트워크의 혼잡을 최소화한다. 

TCP는 이러한 혼잡 제어 동작을 통해 다음과 같은 방식을 사용한다. 
   1) Taho TCP : 혼잡이 감지되면 초기 상태에서 다시 Slow start 상태로 진입. 
   2) Reno TCP : 혼잡이 감지되면 일정 수준 이상에서 다시 Slow start 상태로 진입
   3) AIMD(Additive Increase, Multiplicative Decrease) : 혼잡이 감지되지 않으면 cwnd값을 조금씩 증가. 혼잡이 감지되면 cwnd값을 절반으로 줄임.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[8] Socket 프로그래밍에서 서버와 클라이언트의 동작 절차를 주요 함수 기준으로 설명합니다.

client                  server
---------------------------------
socket                  socket   |                                  1) 첫 번째 단계는 소켓을 생성하는 단계
  |                       |      |
  |                      bind    | open listen                      2) 서버가 사용할 ip주소와 port 번호를 결합
  |                       |      |
  |                     listen   |                                  3) client로부터 요청이 수신되는지 확인
  |    connect request    |
connect ------------->    |                                         4) ip주소와 포트번호로 식별되는 대상에게 연결 요청을 보낸다. / block 방식(결과가 결정되기 전까지는 connect() 실행 안끝남)
  |                     accept                                      5) 데이터 통신을 위한 소켓을 생성한다.
---------------------------------
| write                   read  | client server
| read                    write |    session                        6)  send()와 recv()로 데이터 교환 
---------------------------------
  |                       |
close                    read
                          |
                         close                                       7) 소켓을 닫게됨

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[9] 사용자의 URL 입력 이후 부터, HTTP Req가 HTTP Client에서 전송되기 전에 이뤄져야 하는 동작을 차례대로 설명합니다. (DNS Lookup, TCP 연결 설정)

오리지널 HTTP 1.1의 동작 방식이다.
1. url창을 입력함 (도메인 이름+port 이름(통상적으로 80을 입력함))
2. 웹브라우져는 DNS(Domain Name System) 작업을 통해 호스트 이름을 ip address로 바꿈.
3. 이후에 tcp 연결을 진행
  3-1. ip + port의 주소에 접근
  3-2. HTTP GET request 진행
  3-3. HTTP를 서버로 부터 읽는다.
  3-4. 3-1에서 연결된 connection을 끊는다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[10] HTTP의 4대 메시지를 나열하고, 각각의 기능, 그리고 각각에 대해서 REQ/RES에 포함하는 정보가 무엇인지 설명합니다.

GET: 
  request   : 주소/프로토콜(+버전)/Host 주소/받을 수 있는 정보
  response  : 프로토콜(+버전)/status code/context 타입/길이
PUT(파일을 업로드):
  request   : 파일위치(호스트 주소 아래에 있는)/프로토콜(버전)/Host 주소/content 타입/컨텐츠 길이/
  response  : 프토토콜(버전)/status code/저장된 위치(기본적으로 root)/content 타입/컨텐츠 길이
POST(정보 전달):
  request   : 실행되는 파일(웹서버)/프토토콜(버전)/호스트주소/컨텐츠 타입/컨텐츠 길이
  response  : 프로토콜(버전)/컨텐츠 타입/컨텐츠 길이
DELETE
  request   : 파일위치(target)/프로토콜(버전)/호스트 주소
  response  : 프로토콜(버전)/컨텐츠 타입/컨텐츠 길이

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------ [11] HTTP/2의 다중화 기술은 HTTP/1.1과 어떤 점이 다르며, 어떻게 다중화가 가능한지 설명합니다. ------------

tcp를 순서대로 보내고 순서대로 받음 (최대 8개를 받음)
편법으로 이전 1.1에서는 tcp만큼 세션을 뚫어서 진행했다.

하지만 2에 경우에는 stream으로 구성되며, Frame 단위로 끊어서 제공한다.
하나만 뚫어 놓고 안에서 frame 단위로 집어 넣어서 한 번에 전달함.
이는 서버의 부화도 줄어듦. 1.1 시점에는 순차적으로 하나하나가고 하나하나 내려옴
서버 2는 한번에 복수적으로 처리를 할 수 있음

특정 조건에서는 좋다.

HTTP/2는 HTTP/1.1과 비교하여 다중화(Multiplexing) 기술에서 큰 개선을 제공합니다.
다중화는 여러 개의 요청과 응답을 동시에 처리하여 효율성을 향상시키는 메커니즘입니다. 
아래는 HTTP/2에서의 다중화와 HTTP/1.1과의 차이점에 대한 설명입니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------ [12] HTTP/2에서 HTTP Req/Res 메시지를 어떻게 압축하는지 설명합니다. ------------

Req/Res의 메세지를 압축


binary 프로토콜    : 바이너리 형태로 데이터를 압축해서 보낸다.
header 압축        : 2가지 방식: static table과 dynamic table 따로 존재함.
                  static      : 기본적인 것들 (get, put 등등) 사전식으로 저장 숫자로 바꿈 (그러면 get 대신에 2를 보냄)
                  dynamic     :  이 client가 이 서버에 붙을 때 반드시 필요한 것들을 동적으로 할당한다. 
                                 특정 서버에 대해서는 달라자지만, 계속해서 정보를 교환 및 통신할 때 저장되는 데이터
                  + Huffman코드 -> 값이 변하지만 original에서 약간 변하는 것 / liner하게 변하는 것
                                    동영상처럼 (1과 10의 값의 차이로 영상을 보간하는 방식) 이미지를 구성한다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[13] HTTP/3는 HTTP/2가 (TCP를 사용하기 때문에 해결하지 못하는) 어떤 문제점을 해결하고 있는지, 네트워크에서의 에러 발생과 초기 연결 관점에서 설명합니다.

HTTP/3는 HTTP/2에 비해서 tcp가 아닌 
tcp는 초기에 핸드쉐이크의 긴 과정이 필요하다. tcp인증에 추가적인 TLS는 3번의 인증과정이 필요하기 때문에 오래 걸린다.
하지만 QUIC은 자체에 TLS 인증 과정을 포함하여, QUIC 연결 이후 바로 HTTP 연결을 진행할 수 있기 때문에 초기 연결 지연을 완화한다.
또한 인증을 진행하면서 데이터를 주고 받기 때문에 첫번째로 HTTP request가 오는 시간을 단축할 수 있다.
최초의 데이터를 보내는 시간을 단축할 수 있다.
QUIC은 만약 이전에 통신내역이 있는 경우에는 인증을 넘어간다. 때문에 데이터를 보냄과 동시에 바로 서버에서 response를 보낼 수 있다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[14] SIP 프로토콜을 사용하여 음성 전화를 하는 경우, 발신자와 착신자 간의 연결 설정과 해제 과정을 주요 메시지를 사용하여 설명합니다.

SIP는 한 명 이상의 참가자와의 미디어 세션을 생성, 수정 및 종료하기 위해 설계된 IETF 신호 프로토콜입니다.
SIP는 미디어와 독립적입니다. 미디어는 RTP(실시간 프로토콜)를 통해 전송됩니다.
SIP는 텍스트 기반의 요청-응답 프로토콜이라는 점에서 HTTP에서 많은 영감을 받았습니다.

RCS라는 서버를 통해서 2명의 클라이언트끼리 메세지를 보냄

# 연결 설정 과정:
1. INVITE (초대):
   -  발신자가 수신자에게 보냄
   -  발신자는 SIP INVITE 메시지를 사용하여 착신자에게 통화를 초대합니다. 
      통화에 필요한 정보와 SDP(Session Description Protocol) 등이 포함됩니다.
2. 180 Ringing (벨 울림):
   -  수신자가 발신자에게 보냄.
   -  SIP 180 Ringing 응답을 보낼 수 있습니다. 
3. 200 OK (성공):
   -  수신자가 발신자에게 보냄
   -  착신자가 수락하여 통화를 받을 경우, SIP 200 OK와 SDP을 전달함.
4. ACK (확인):
   -  발신자가 수신자에게 보냄
   -  발신자는 수락 응답을 확인하기 위해 SIP ACK 메시지를 보냅니다. 
      이로써 통화가 확립되고 양 측 간에 음성 데이터 전송이 시작됩니다.

# 연결 해제 과정:
1. BYE (종료):
   - 통화를 종료하려는 한 측이 SIP BYE 메시지를 상대방에게 보냅니다.
2. 200 OK (성공):
   - 상대방은 BYE 메시지를 받고 통화를 종료할 수 있음을 의미하는 SIP 200 OK 응답을 보냅니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[15] WebRTC에서 STUN 서버와 TURN 서버의 역할에 대해서 설명합니다.

WebRTC(웹 실시간 통신)는 웹 브라우저 간에 실시간 통신을 가능케 하는 개방형 프로젝트입니다. 
WebRTC를 사용하는 응용 프로그램은 두 피어(peer) 간의 미디어 및 데이터 전송을 활성화하며, 이때 STUN 서버와 TURN 서버가 중요한 역할을 합니다.

서버가 없는 서로간의 화상희의 채팅을 진행하고자 함.
하지만 실제로는 서버가 많이 투입됨. 

ex) google meet

STUN 서버: 내가 누구이고 상대방이 누구인지 확인 => 내부 ip + port 주소기 때문에 누군지 확인해야함.
            내가 누구로 바뀌고 누구랑 통신하는지 확인함.

signaling 서버: 연결을 해제하고 설정하는 서버

TURN 서버:  N에 대한 특정 수를 넘어가면 돈을 요구함
            데이터 기록 /  개인 정보외의 전체 정보에 대해서 
            소규모 회의에서는 직접 주고 받음
            인원이 특정 수를 넘어가면 브라우져가 직접 보내는 것이 아니고 클라가 서버에 보내고 서버가 클라에게 정보를 뿌림

트래픽을 직접 주고 받음

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[16] Cloud Computing이 시작하게된 계기를 Public Cloud 사업자와 사업을 시작하는 벤처 회사 입장에서 설명합니다.

Cloud Computing이 시작하게 된 계기는 다양한 요인들이 결합된 결과입니다. 특히, Public Cloud 사업자와 벤처 회사들은 다음과 같은 이유로 Cloud Computing을 채택하게 되었습니다.

Cloud 제공자의 관점에서 겹치는 시간 및 날짜에 대해서 up-down의 차이가 매우 큼
밴처 사업자 관점에서는 서비스에 대한 HW를 갖추기에는 초기 비용에 대한 부담이 있음 / 서비스가 망했는데 HW가 많은 경우가 생길 수도 있음

데이터 볼륨의 폭발적인 증가
   Petabyte, Exabyte, Big-Data에 대해 쉽게 언급
   민간 조직의 컴퓨팅 및 스토리지 제한

하드웨어 및 소프트웨어에 대한 신뢰성 문제도 Cloud Computing에 대한 관심을 끌게 된다.
   매년 서버의 2~4%가 사망합니다.
   매년 디스크 드라이브의 1-5%가 수명을 다합니다.
   20%의 관리 문제는 의도하지 않은 결과를 초래합니다(사람의 실수)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[17] Public Computing의 3대 모델을 나열하고, 각각 어떤 사항을 제공하는지 설명합니다.

1) Infrastructure as a Service(IaaS) : Hardware, OS, Virtual Machine
                                       AWS
2) Platform as a Service (PaaS) : Hardware, OS, Virtual Machine, OS Service, Framework
                                 Microsoft Azure
                                 Google App Enigne
                                 해당 플랫폼이 만든 middle ware를 빌려주는 개념이라고 보면 된다.
3) Software as a Service (Saas) : Application

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[18] EC2와 S3가 무엇인지 설명합니다.

간단히 말하면, EC2는 가상 서버를 제공하는 클라우드 컴퓨팅 서비스이며, S3는 객체 스토리지 서비스로 파일이나 데이터를 저장하고 검색할 수 있게 해주는 서비스입니다. 
EC2는 가상 서버를 사용하여 애플리케이션을 실행하고, S3는 데이터를 안전하게 저장하고 필요할 때 검색할 수 있게 도와줍니다
EC2 : Virtual Computer를 생성하고 실행할 수 있는 AWS에서 제공하는 클라우드 컴퓨팅
서비스. S3 : Storage 서비스

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[20] Virtual Machine 기반의 Computing의 Guest OS over Host OS이 문제로 작용한 사용자는 누구이며, 왜 문제인지 설명합니다.

Private Cloud를 이용하는 사용자의 경우, 일반적으로 Cloud 내 이용자들의 Hardware와
OS가 무엇인지 명확하고, 사용목적과 용도 또한 알 수 있다. 그런 상황에서 일반적인 Virtual
Machine 기반의 환경에서 Host OS 위에 Guest OS를 올려 사용하는 행위는 불필요한 행위
이며, 자원을 비효율적으로 사용하게 된다. # Private Cloud 내 상황 설명. 사용 용도와 목적이 명확함.

Guest OS over Host OS
Guest와 Host의 OS가 같다면 같은 OS의 그위에 하이퍼바이저가 그 위에 Guest OS가 올라가 있는 구조로 
같은 OS가 2개나 존재하기 때문에 Host는 같은 일을 2번이나 하기 때문에 효율성이 떨어지는 손해이다


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[21] Container 기술이 Guest OS over Host OS 문제를 해결할 수 있는 이유와, Container에 포함되는 내용물은 무엇인지 설명합니다.

Container는 공유된 OS에서 Application들은 각각 격리되어 실행할 수 있도록 가상화하기
때문이다. 이때, Container는 Application이 실행되는데 필요한 프로그램, Binary, Library
과 같은 종속성이나 Path들을 포함시켜 가상화하고 그 외에 필요한 운영체제나 실행 환경등
은 공용으로 사용된다.
Container: docker와 같은 소프트웨어를 통해서 구현되는 가상화 계층으로, 단일 어플리케이션 구현을 위한 최소한의 환경을 구축해놓은 공간이다. 
         이는 호스트의 OS를 공유하므로 자체의 무게가 가벼워지며 실제로 전체 환경에서 프로세스가 수행되기 때문에 Host OS 문제를 해결할 수 있다.
         컴퓨터 과학 교과서에서는 프로세스(컨테이너)가 "자체 주소 공간", "프로그램", "CPU 상태 및 프로세스 테이블 항목"을 갖는 것으로 정의합니다.
         컨테이너는 고립되어 있지만, OS를 공유하며, 적절한 bins/libraries를(-> 안할 수 도 있음) 컨테이너끼리 공유할 수도 있다.


-- 교수님 pdf 내용 --
그러나 오늘날의 소프트웨어 환경에서는 이것이 더 이상 전체 이야기가 아니다.
프로그램 텍스트는 실제로 파일 시스템에서 프로세스 주소 공간으로 매핑된 메모리이며 
프로그램 자체 외에도 수십 개의 공유 라이브러리로 구성되는 경우가 많습니다. 
따라서 이러한 모든 파일은 실제로 프로세스의 일부입니다.

추가 docker & Kubernetes

:Docker( https://www.docker.com/ )는 Docker, Inc.에서 홍보하는 컨테이너를 제공하는 소프트웨어 기술입니다.
Windows 및 Linux에서 운영 체제 수준 가상화의 추가 추상화 및 자동화 계층을 제공합니다.
cgroup 및 커널 네임스페이스와 같은 Linux 커널의 리소스 격리 기능과 OverlayFS 등과 같은 통합 가능 파일 시스템을 사용하여 
독립적인 "컨테이너"가 단일 Linux 인스턴스 내에서 실행되도록 허용하여 가상 머신 시작 및 유지 관리에 따른 오버헤드를 방지합니다. (VM)

: Kubernetes는 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하기 위한 오픈 소스 컨테이너 오케스트레이션 시스템입니다.
원래 Google에서 설계했으며 현재 Cloud Native Computing Foundation에서 유지관리하고 있습니다.
이는 "호스트 클러스터 전체에서 애플리케이션 컨테이너의 배포, 확장 및 운영을 자동화하기 위한 플랫폼"을 제공하는 것을 목표로 합니다.
첫 번째 릴리스부터 Docker를 포함한 다양한 컨테이너 도구와 함께 작동합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[22] Microservice 개념에 의해서 만들어지는 프로그래밍(들)이 과거 하나의 강력한 프로그램으로 만드는 경우 대비 가질수 있는 장점들을 기술적/비기술적인 측면에서 설명해 봅니다.

Microservice 개념에 의해서 만들어지는 프로그램의 경우, 기술적으로 한 언어나 프레임워크 에 국한되지 않고 Polyglot한 개발이 가능하다. 
따라서 개발 시 특정 기능에 특화된 언어와 프레임워크를 택하여 성능 향상과 최적화가 용이하다. 
또한 하나의 프로그램에서 장애가 발생 하더라도 전체 프로그램에 영향이 적고 복구가 쉽다. 
비기술적으로는 Microservice로 만들어지는 프로그램들이 각각의 독립적인 팀으로 구성되어 
개발하는 입장에서 모든 프로그램의 구성과 관계를 고려하지 않아도 되며, 특정 기능에 대한 전문성만 갖추어도 충분하다. 
또한 새로운 기능이나 요구사항이 발생 시 이를 유연하게 대처가 가능하며, 
필요에 따라 규모의 조절이 비교적 자유로워 비용과 자원을 효율적으로 사용이 가능하다. 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[23] Game 서버 중, Master Server와 Game (Logic) Server의 역할에 대해서 설명합니다.

게임 서버는 높은 트래픽과 높은 cpu/ram 사용량을 가지게 된다. 이에 반해 Master server는 적은 트래픽과 적은 cpu/ram 사용량을 보인다.

게임서버는 게임 플레이의 로직을 담당하며 날아다니는 모든 총알, 움직이는 모든 개체 및 캐릭터는 플레이어 간에 지속적으로 동기화하여 높은 트래픽 사용량을 보인다.
높은 CPU 사용량 - 자주 실행해야 합니다. 물리학, 충돌 계산, 레이캐스팅 수행, 모든 플레이어의 입력 처리 등.
게임 서버의 이러한 "집약적" 특성은 단일 시스템 내에서 실행할 수 있는 게임 서버 수에 제한을 만듭니다. 

마스터 서버는 
Client가 session Layer에 진입하면 auth check를 진행한다.
game server는 Master server에 대한 통제를 따른다. 
마스터 서버는 모든 것이 연결되는 서버 유형이다. 
플레이어부터 모든 게임 서버들이 연결된다.
플레이어에게 어떤 게임 서버가 실행되고 있는지 또한 어디에 할당되는지 및 서로 통신이 (플레이어끼리, 서버와 클라이언트가) 통신될수 있도록 기능한다.

-- 게임 서버 전용 서버의 존재(?) 이유 -- 

전용 서버는 관리에 필요한 경우를 제외하고 직접적인 입력이나 출력을 지원하지 않고 게임 세계를 시뮬레이션합니다. 
플레이어가 게임을 보고 상호 작용하려면 별도의 클라이언트 프로그램으로 서버에 연결해야 합니다.
전용 서버의 가장 큰 장점은 전문 데이터 센터에서 호스팅하기에 적합하며 이에 수반되는 모든 안정성 및 성능 이점입니다. 
또한 원격 호스팅은 동일한 시스템이나 로컬 네트워크에서 서버를 호스팅하고 연결하는 플레이어가 가질 수 있는 짧은 대기 시간 이점을 제거합니다.

그러나 전용 서버를 실행하려면 비용이 듭니다. 비용은 때로는 게임 개발자가, 때로는 클랜 그룹이 충족하지만, 
두 경우 모두 대중은 연결할 서버를 제공하는 제3자에 의존합니다. 이러한 이유로 대부분의 게임은 전용 서버를 사용합니다.

-- peer to peer --
   이 문서에서 언급된 클라이언트/서버 모델에서 클라이언트는 서버에서 처리된 데이터를 받아와 아무 생각 없이 표시합니다. 
   "피어 투 피어" 모델에서는 서버가 없고, 각 "피어"가 서로의 입력을 받아 결과를 직접 결정합니다. 
   P2P는 일반적으로 액션 게임에서는 쓸모 없다고 여겨지지만, 토큰 수가 많고 플레이어 수가 적은 실시간 전략 게임에서는 여전히 흔합니다.
   
   그러나 P2P에는 몇 가지 단점이 있습니다. 
      (1) 모든 피어를 동기화하는 것은 매우 어렵습니다. 
      (2) 중간에 새로운 피어가 합류하는 것은 어렵습니다. 
      (3) 각 피어는 모든 다른 피어와 통신해야 하며 연결된 플레이어 수를 제한합니다. 
      (4) 각 피어는 다음 "네트워크 프레임"을 시뮬레이션하기 전에 다른 모든 피어의 메시지를 기다려야 하므로 
            모든 플레이어는 연결이 가장 나쁜 플레이어와 동일한 대기 시간을 경험하게 됩니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[24] Game 서버가 제공하는 실시간성 서비스는 어떤 것들이 있는지 설명합니다. (네트워크 기능, 콘텐츠 생성 기능 등 측면을 강의노트의 서버 예제들을 참조하여 답변함)

실시간성 서비스는 아래와 같은 
Game Service 측면에서 플레이어 관리, 멀티 플레잉, 거래, 순위 시스템, 일반적인 로직등을 담당한다.
실시간 분석 측면에서는 실시간 파이프라인, 대쉬보드, A/B testing, 보고등이 있다.
LiveOps 측면에서 메세지, 컨텐츠 업데이트, 인게임 프로모션, 리얼타임 세그먼테이션

Kubernetes는 또한 운영을 단순화합니다.
멀티플레이어 게임은 결코 전용 게임 서버가 아닙니다. 
항상 지원 서비스, 계정 관리, 인벤토리, 마켓플레이스 등이 있습니다. 
Kubernetes를 지원 서비스와 전용 게임 서버를 모두 실행할 수 있는 단일 플랫폼으로 사용하면 필요한 운영 지식과 지원 개발팀의 복잡성이 크게 줄어든다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[25] Physical Computing 이란 무엇인지, Environment와 System 간의 상호작용을 중심으로 설명합니다.

피지컬 컴퓨팅이란 결국 "센서"로 아날로그 세계를 감지하고, system에서 input을 processing하며, 
output을 Physical world에 "Actuator"로 재구축하는 것을 의미한다.

pdf 설명:
피지컬 컴퓨팅이란 아날로그 세계를 감지하고 반응할 수 있는 소프트웨어와 하드웨어를 사용하여 대화형 물리적 시스템을 구축하는 것을 의미합니다.
센서와 마이크로 컨트롤러를 사용하여 아날로그 입력을 소프트웨어 시스템으로 변환하거나 
모터, 서보, 조명 또는 기타 하드웨어와 같은 전자 기계 장치를 제어하는 수제 예술, 디자인 또는 DIY 취미 프로젝트를 가장 자주 설명합니다.
학계와 산업계에서 종종 전기 공학, 메카트로닉스, 로봇 공학, 컴퓨터 과학, 특히 임베디드 개발로 언급되는 활동 범위와 교차합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[26] CPS란 무엇인지, digital twin의 개념과, (CPS를 구성하는) Computation/Communication/Contol을 중심으로 설명합니다.

사이버물리시스템(CPS)은 컴퓨터 기반 알고리즘에 의해 제어되거나 모니터링되는 메커니즘으로, 인터넷 및 사용자와 긴밀하게 통합되어 있습니다.
사이버 물리 시스템(CPS)에는 스마트 그리드, 자율 자동차 시스템, 의료 모니터링, 로봇 시스템 및 자동 조종 항공 전자 장치가 포함됩니다.
사이버물리시스템(CPS)은 학제간 접근 방식, 사이버네틱스, 메카트로닉스, 디자인 및 프로세스 과학 이론을 통합합니다.
CPS(사이버 물리 시스템)도 사물 인터넷(IoT)과 유사하며 동일한 기본 아키텍처를 공유합니다. 
그럼에도 불구하고 CPS는 물리적 요소와 계산적 요소 사이의 더 높은 조합과 조정을 제공합니다.

Digital Twin은 CPS의 중요한 개념 중 하나로, 실제 물리적 개체나 프로세스의 디지털 모델을 나타냅니다. 
이 디지털 모델은 센서 데이터, 시뮬레이션, 통신 등을 통해 실시간으로 업데이트되며, 물리적 세계의 동작을 디지털적으로 시뮬레이션하고 모니터링하는 데 사용됩니다.
Digital Twin은 물리적인 시스템의 동작을 추적하고 문제를 사전에 예측하며, 유지보수 및 최적화에 활용됩니다. 
이것은 CPS에서 중요한 역할을 하며, 현실 세계의 물리적인 상태를 디지털적으로 반영하여 시스템을 효율적으로 관리하는 데 도움을 줍니다.

CPS의 요소들은 아래의 관계에 있음

Computation ---[Physical]---> control ---[System]--->  Communication ---[cyber]---> Computation  

Computation/Communication/Control (계산/통신/제어):
1. Computation (계산): CPS에서는 실시간 데이터 처리 및 분석을 위한 강력한 계산 능력이 필요합니다. 
                        이는 센서 및 액추에이터와 상호 작용하면서 물리적 프로세스를 지속적으로 모니터링하고 제어하는 데 사용됩니다.

2. Communication (통신): CPS의 성공에는 실시간 통신이 매우 중요합니다. 
                        센서에서 수집한 데이터를 신속하게 분석하고, 이에 기반하여 다른 시스템에 명령을 전달하거나 필요한 정보를 전송하는 것이 필수적입니다.

3. Control (제어): 물리적 프로세스를 최적화하고 안전하게 유지하기 위해 제어 기술이 사용됩니다. 
                  제어 시스템은 센서 데이터 및 디지털 트윈 정보를 기반으로 결정을 내리고 액추에이터를 통해 물리적 시스템에 영향을 줍니다.