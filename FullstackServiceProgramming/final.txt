------------------------------------------------------------------------------------------------------------------------------------------------------------------
[1] Development 과정에서 활용 할 수 있는 Hot-Reload와 Hot-Restart는 무엇이고, 어떤 차이점이 있는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

Hot-Restart와 Hot-Reload는 개발과정에서 사용되는 디버깅 기술이다.
Hot-Reload는 애플리케이션이 실행중일 때 코드 일부를 수정하면 해당 사항을 즉시 적용해서 애플리케이션을 다시 로드하는 기술이다.
Hot-Restart는 애플리케이션을 중지하고 다시 시작하는 것을 의미하는 것으로 일부 혹은 전체를 다시 로드해서 변경사항을 적용한다.

차이점:
- 실행 중인 애플리케이션의 상태:
  - Hot-Reload는 애플리케이션을 중지하지 않고 코드 일부를 변경하며, 상태를 유지합니다.
  - Hot-Restart는 애플리케이션을 중지하고 다시 시작하므로, 상태를 초기화하거나 변경할 수 있습니다.
- 반영되는 변경의 범위:
  - Hot-Reload는 코드 변경에 중점을 두며, 주로 개발 중인 모듈 또는 코드 부분에 대한 변경을 반영합니다.
  - Hot-Restart는 애플리케이션 전체나 일부를 다시 로드하여 구성 변경 사항 등을 반영합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[2] Dart/Flutter의 Toolchain 중 Development 목적의 경우에 사용하는 컴파일러의 유형은 무엇이고, 어떻게 동작 하는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

JIT와 VM이 결합된 것을 Native에서 사용하고, web의 경우에는 dartdevc를 사용한다.
Aot+runtime를 Native에서 사용하고, web의 경우에는 dart2js를 사용한다.

개발 중에는 빠른 개발자 주기가 반복에 매우 중요합니다.
Dart VM은 증분 재컴파일(핫 리로드 활성화), 실시간 측정 항목 수집(DevTools 지원) 및 풍부한 디버깅 지원 기능을 갖춘 
JIT(Just-In-Time 컴파일러)를 제공합니다.

JIT 컴파일러의 장점:
- 빠른 반복 개발: JIT 컴파일러는 코드를 실행 시점에 컴파일하므로, 
   코드 변경 사항이 즉시 반영되어 개발자가 빠르게 실험하고 디버깅할 수 있습니다.
- 동적인 특성: Dart 언어는 동적 타이핑을 지원하며, 
   JIT 컴파일러는 이러한 동적 특성을 적극적으로 활용하여 유연한 프로그래밍을 가능케 합니다.

단점:
- 런타임 오버헤드: JIT 컴파일러는 실행 시점에 코드를 컴파일하므로, 일부 런타임 오버헤드가 발생할 수 있습니다. 
                  그러나 최적화 기술을 통해 이러한 오버헤드를 최소화하려고 노력합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[3] Dart/Flutter의 Toolchain 중 Production 목적의 경우에 사용하는 컴파일러의 유형은 무엇이고, 어떻게 동작 하는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

앱 스토어에 게시하든 프로덕션 백엔드에 배포하든 앱을 프로덕션에 배포할 준비가 되면, 
Dart AOT(Ahead-of-Time) 컴파일러는 기본 ARM 또는 x64 기계어 코드로 컴파일할 수 있습니다. 
AOT 컴파일 앱은 일관되고 짧은 시작 시간으로 실행됩니다.
AOT 컴파일 코드는 견고한 Dart 유형 시스템을 적용하고, 
빠른 객체 할당 및 세대별 가비지 수집기를 사용하여 메모리를 관리하는 효율적인 Dart 런타임 내에서 실행됩니다.

AOT 컴파일러의 장점:
- 성능 향상: 미리 컴파일된 코드는 기계어로 직접 실행되므로, 런타임 오버헤드가 줄어들어 성능이 향상됩니다.
- 배포 용이성: 애플리케이션은 특정 플랫폼에 최적화된 네이티브 실행 파일로 패키징되어 배포되므로, 
               플랫폼별로 최적화된 실행 파일을 제공할 수 있습니다.

단점:
- 빠른 반복 개발 어려움: AOT 컴파일러를 사용하는 경우, 코드 변경이 발생할 때마다 전체 애플리케이션을 다시 컴파일해야 하므로, 
                        빠른 반복 개발이 어려울 수 있습니다.

Production 목적에서 AOT 컴파일러를 사용하면 성능과 배포 용이성을 높일 수 있습니다. 
Flutter는 특히 AOT 컴파일러를 사용하여 다양한 플랫폼에 효과적으로 배포할 수 있는 크로스 플랫폼 프레임워크로서 인기를 얻고 있습니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[4] Dart/Flutter의 Toolchain을 Development 목적과 Production 목적으로 나누는 경우, 각각의 경우에 대한 장단점을 비교합니다. 
이때 비교 항목은 3가지 정도로 본인이 선택합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

JIT                                vs  AOT
slow startup time(long warm up)        fast (instant) startup times
peak performance                       consistent performance
complies code at runtime               complies code before runtime
suite of debugging tools               no debugging tools
hot Reload                             testing real - world performance
complies/tun time: 1s/670ms            complies/run time: 3s/27ms

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[5] Flutter에는 Skia 및 Impeller와 같은 렌더링 라이브러리가 포함되어 있습니다. 
Reactive Native와 같은 전통적인 Cross Platform과 비교해서, 프로그램의 동작이 어떻게 다른지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

react Native는 js코드와 OEM widget인 여러 플랫폼의 원본 widget에 대해서 맞추기 위해서, 
Bridge를 중간에 이용하여 native 코드와 통신해 화면을 그린다.
js 코드가 여러 플랫폼에서 적용되는 widget에 정형화된 틀로 이미지를 제공할 수 없기에 Bridge를 사용한다.

이에 반해 flutter는 위젯 기반의 구조로 skia와 Impeller와 같은 랜더링 엔진을 자체적으로 가지고 있어
Bridge와 같은 중간 과정 없이, 화면에 바로 그릴 수 있으며 이는 플랫폼에 대해서 모두 적용될 수 있어 매우 확장적이다.


React Native:
설명에서 언급한 대로 React Native는 JavaScript 코드와 OEM(Original Equipment Manufacturer) widget 간의 중간 과정으로 Bridge를 사용합니다. 
이는 JavaScript 코드가 네이티브 모듈과 통신하여 화면을 그리게 됩니다.
JavaScript 코드는 여러 플랫폼의 원본 widget에 정형화된 틀로 이미지를 제공하기 어렵기 때문에 Bridge를 통해 네이티브 코드와 통신하여 각 플랫폼에 맞는 화면을 그립니다.

Flutter:
Flutter는 Dart 언어를 사용하며, 위젯 기반의 구조로 Skia와 Impeller와 같은 렌더링 엔진을 내장하고 있습니다.
설명에서 언급한 대로 Flutter는 Bridge와 같은 중간 과정 없이 화면을 바로 그릴 수 있습니다. 
이는 네이티브 코드와의 통신을 줄이고, 플랫폼에 독립적으로 동작할 수 있게 만듭니다.
Flutter는 플랫폼에 대한 종속성이 낮고, 하나의 코드베이스로 여러 플랫폼에서 동작할 수 있어 매우 확장적이라고 설명되었습니다.



- React Native는 JavaScript와 Native 코드 간의 통신을 위한 "Bridge"를 사용합니다. 
   JavaScript 코드가 실행되고, Native 모듈과 통신을 통해 네이티브 기능을 호출합니다.
- OEM(Original Equipment Manufacturer) Widget은 React Native에서 사용자 인터페이스를 
   정의하는 데 사용되는 네이티브 위젯입니다. 이것은 각 플랫폼의 원본 위젯에 해당합니다.

- React Native의 Bridge와 유사하게, Flutter는 플랫폼 채널을 제공하여 
   Dart 코드와 네이티브 코드 간에 통신할 수 있도록 합니다.
- Platform Channels를 사용하면 Flutter 애플리케이션이 네이티브 기능에 액세스하거나 
   반대로 네이티브 코드가 Flutter 애플리케이션과 상호 작용할 수 있습니다.

요약하면, React Native는 JavaScript와 네이티브 코드 간의 통신을 위한 브릿지와 OEM 위젯을 사용하며, 
Flutter는 위젯 기반의 구조와 Skia를 통한 일관된 렌더링 엔진을 사용합니다. 
또한, Flutter는 플랫폼 채널을 통해 Dart 코드와 네이티브 코드 간에 통신합니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[6] Flutter에는 Skia 및 Impeller와 같은 렌더링 라이브러리가 포함되어 있습니다. 
Reactive Native와 같은 전통적인 Cross Platform과 비교해서, 프로그램을 개발하는 개발자 측면에서 기대할 수 있는 장점을 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
크로스 플랫폼 프레임워크는 기본적으로 Android 및 iOS와 같은 각 플랫폼의 UI 라이브러리 위에 
추상화 계층을 생성하여 플랫폼 간의 표현 차이를 완화하는 방식으로 동작합니다. 
이러한 프레임워크에서는 주로 JavaScript와 같은 해석 언어를 사용하여 앱 코드를 작성하며, 
이로써 Java 기반 Android나 Objective-C 기반 iOS 시스템 라이브러리와의 상호 작용이 필요합니다. 
이러한 접근은 특히 UI와 앱 로직 간의 상호 작용이 많은 경우에 상당한 오버헤드를 발생시킵니다.

한편, Flutter는 자체적으로 위젯 세트를 활용하여 시스템 UI 위젯 라이브러리를 우회하고, 이를 통해 추상화를 최소화합니다. 
Dart 코드로 작성된 Flutter의 시각적 요소는 Skia(또는 향후 Impeller)를 사용하는 네이티브 코드로 컴파일됩니다. 
또한, Flutter는 엔진의 일부로 자체 Skia 복사본을 포함하고 있어, 
개발자는 휴대폰이 새로운 Android 버전으로 업데이트되지 않은 경우에도 앱을 업그레이드하여 최신 성능 개선 사항을 지속적으로 적용할 수 있습니다. 
이러한 특성은 Flutter가 다양한 플랫폼에서도 일관된 동작을 보장한다는 장점으로 나타납니다.


1. 고성능 및 일관된 UI
2. Hot Reload
3. 단일 코드베이스
4. 네이티브 성능과 가까운 성능
5. 다양한 위젯 및 커스터마이징
6. 강력한 커뮤니티와 지원

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[7] gRPC가 RESTful API와 비교해서 가지는 장점을 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

Feature        |  gRPC                    vs          HTTP APIs with JSON
--------------------------------------------------------------------
contract       |  Required                            optional
Protocol       |  HTTP/2                              HTTP
payload        |  ProtoBuf(small, binary)             JSON
client         
code-generate  |  YES                                 OpenAPI + third party tooling


gRPC (gRPC Remote Procedure Calls)는 Google에서 개발한 오픈 소스 RPC (Remote Procedure Call) 프레임워크로, 
RESTful API와는 다른 접근 방식을 채택하고 있습니다. 

1. 효율적인 직렬화 및 전송 프로토콜:
   - gRPC:
     - Protocol Buffers를 사용하여 데이터를 직렬화하므로, JSON보다 더 적은 바이트를 전송합니다.
     - HTTP/2를 사용하며, 하나의 연결에서 여러 RPC를 병렬로 처리할 수 있어 네트워크 자원을 효율적으로 사용합니다.
   - RESTful API:
     - 주로 JSON을 사용하여 데이터를 직렬화하며, 텍스트 기반의 직렬화 형식은 크기가 큰 데이터 전송에 비효율적일 수 있습니다.
     - HTTP/1.1은 단일 연결에서 직렬적으로 데이터를 전송하므로, 병렬 처리에 제한이 있습니다.

2. 자동 코드 생성 및 강력한 타입 시스템:
   - gRPC:
     - Protocol Buffers를 사용하면 클라이언트 및 서버 코드를 자동으로 생성할 수 있습니다.
     - 강력한 타입 시스템을 제공하여 타입 오류를 컴파일 시간에 확인할 수 있습니다.
   - RESTful API:
     - 대부분의 경우 수동으로 클라이언트 및 서버 코드를 작성해야 하며, 강력한 타입 시스템이 부재할 수 있습니다.
     - 동적 타입 언어의 경우 런타임에 타입 오류를 확인할 수 있습니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------
[8] gRPC를 사용해서 개발하는 경우, RPC과 RESTful API과 비교해서 개발의 용이성이 우수할 수 있는 서비스 모델을 기술하고, 이유를 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

gRPC와 RESTful API는 각각 다른 서비스 모델을 가지고 있으며, gRPC가 우수한 개발의 용이성을 제공하는 서비스 모델을 설명하겠습니다.

### 서비스 모델: 양방향 스트리밍 (Bidirectional Streaming)

gRPC에서의 양방향 스트리밍:
- 기존 RPC는 단방향 전송만 가능하다.
- gRPC에서는 클라이언트와 서버 간에 양방향 스트리밍이 가능합니다.
- 클라이언트와 서버 간에 여러 메시지를 동시에 전송할 수 있으며, 서버는 클라이언트로부터 메시지를 받는 동시에 메시지를 보낼 수 있습니다.
- 실시간 데이터 전송이 필요한 경우, 양방향 스트리밍은 효과적인 패턴을 제공합니다.

이유:
1. 실시간 통신:
   - 양방향 스트리밍은 실시간 데이터 전송이 필요한 시나리오에 적합합니다. 예를 들어, 실시간 채팅, 주식 시장 데이터 업데이트, 실시간 이벤트 스트리밍 등에 유용합니다.
   - RESTful API에서는 서버 푸시가 어려우므로, 클라이언트가 주기적으로 서버에 요청을 보내거나 WebSocket과 같은 별도의 메커니즘을 사용해야 합니다.

2. 효율적인 양방향 통신:
   - 양방향 스트리밍은 클라이언트와 서버 간에 효율적이고 실시간인 양방향 통신이 가능하도록 합니다.
   - RESTful API에서는 요청/응답 모델을 따르기 때문에 클라이언트에서 서버로의 푸시가 어려울 수 있습니다.

3. 단일 연결로 다양한 메시지 교환:
   - gRPC의 양방향 스트리밍은 하나의 연결을 통해 여러 메시지를 교환할 수 있습니다.
   - RESTful API에서는 여러 요청을 보내거나 여러 커넥션을 열어야 할 수 있으므로, 이러한 유연성이 부족할 수 있습니다.

4. 효율적인 자원 사용:
   - 하나의 연결을 통한 다양한 메시지 교환은 네트워크 자원을 효율적으로 사용할 수 있습니다.
   - RESTful API에서는 여러 요청 및 응답을 주고받을 때마다 새로운 연결을 맺어야 하므로 네트워크 자원 소모가 증가할 수 있습니다.

이러한 이유로, gRPC의 양방향 스트리밍은 효율적이고 실시간인 양방향 통신이 필요한 상황에서 개발의 용이성을 높일 수 있는 서비스 모델을 제공합니다.


------------------------------------------------------------------------------------------------------------------------------------------------------------------
[9] Design Pattern은 무엇이며, 소프트웨어 개발 과정 중 어느 시점에서 어떻게 활용 가능한지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
소프트웨어 설계의 특정 상황 내에서 일반적으로 발생하는 문제에 대한 일반적이고 재사용 가능한 솔루션입니다.
소스나 기계어 코드로 직접 변환할 수 있는 완성된 디자인이 아닙니다.
다양한 상황에서 사용할 수 있는 문제 해결 방법에 대한 설명 또는 템플릿입니다.
디자인 패턴은 프로그래머가 애플리케이션이나 시스템을 디자인할 때 일반적인 문제를 해결하는 데 사용할 수 있는 공식화된 모범 사례입니다.
디자인 패턴은 프로그래밍 패러다임 수준과 구체적인 알고리즘 수준 사이의 중간에 있는 컴퓨터 프로그래밍에 대한 구조화된 접근 방식으로 볼 수 있습니다.

디자인 패턴은 소프트웨어 디자인에서 자주 발생하는 문제에 대한 해결책을 재사용 가능한 형태로 정리한 것입니다. 
이는 고수준의 설계 문제에 대한 효과적인 솔루션을 제공하여 소프트웨어의 유지보수성, 확장성, 유연성을 향상시키기 위해 사용됩니다. 
디자인 패턴은 경험이 많은 소프트웨어 개발자들이 반복적으로 사용해왔고 검증된 솔루션이라고 할 수 있습니다.

디자인 패턴의 주요 특징:
1. 재사용성: 디자인 패턴은 고려해야 할 디자인 문제에 대한 일반적인 해결책을 제공하여 개발자가 재사용할 수 있도록 합니다.
2. 유연성: 디자인 패턴은 변경에 대응하기 쉬운 코드를 작성할 수 있도록 돕습니다.
3. 가독성 및 이해성: 디자인 패턴은 코드의 가독성과 이해성을 향상시키는 역할을 합니다.



------------------------------------------------------------------------------------------------------------------------------------------------------------------
[10] Design Pattern 중 Clean Architecture의 3계층 layer와 이의 내부 요소를 그림으로 도식화 하고, 각각의 상호 작용에 대해서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

각각의 layer가 분리된 계층 분리가 잘 이루어져 있다.

------------------------------------------------
presentation |  business logic    | data Acess |
------------------------------------------------
      action                 Data I/O
view ----------> Interactor <------> Repository
  ^                 |                 |
  |           update| <---------------|
  |                 |       
  |<------------ appstate
      binding


1. View:
   - View 계층은 사용자 인터페이스(UI)와 관련된 로직을 담당합니다. 
      사용자의 입력을 받아 비즈니스 로직 계층으로 전달하고, 비즈니스 로직 계층에서 반환된 데이터를 사용자에게 표시합니다. 
      View는 가능한 최소한의 로직을 포함하며, 주로 사용자와의 상호작용을 처리하고 화면에 데이터를 표시하는 역할을 합니다.

2. Interactor (또는 Use Case):
   - Interactor는 비즈니스 로직을 담당하는 계층입니다. 
      사용자의 요청을 받아 실제 비즈니스 규칙에 따라 데이터를 처리하고, 결과를 반환합니다. 
      Interactor는 어플리케이션의 핵심 비즈니스 로직을 구현하며, 
      외부 세계와의 상호작용을 처리하기 위해 Repository와 통신할 수 있습니다.

3. AppState (또는 Entities 또는 Domain Model):
   - AppState는 어플리케이션의 핵심 엔터티 또는 도메인 모델을 나타냅니다. 
      이 계층은 어플리케이션의 핵심 데이터 구조 및 비즈니스 객체를 정의하고, 이들 객체 간의 관계와 규칙을 책임집니다. 
      AppState는 비즈니스 논리의 핵심을 포함하며, 다른 계층에서는 이를 변경하지 않고 사용합니다.

4. Repository:
   - Repository는 데이터의 영속성과 관련된 로직을 처리합니다. 
      데이터베이스, 외부 API, 파일 시스템 등과의 상호작용을 추상화하고, 
      이를 통해 데이터를 가져오거나 저장합니다. 
      Repository는 데이터 액세스의 세부 사항을 캡슐화하며, 
      Interactor와 AppState 계층 사이에서 데이터를 중개하는 역할을 합니다.

이러한 계층들은 서로 의존성을 갖지만, 의존성의 방향은 외부에서 내부로 향하도록 설계됩니다. 
즉, 외부 계층은 내부 계층에 의존하지만, 내부 계층은 외부 계층에 의존하지 않습니다. 
이러한 설계는 유연성, 테스트 용이성, 유지보수성 등을 강화하는 데 도움이 됩니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[11] Design Pattern 중 MVVM Pattern(Architecture)의 3계층 layer와 이의 내부 요소를 그림으로 도식화 하고, 각각의 상호 작용에 대해서 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------

mvc 패턴:
중요

model view controller
model에서 필요한 것을 가져옴
application delegate에서 보여줌

java spring framework

apple ios에서 ui kit에서 mvc를 강제함
표준을 지목한 사례이다.

이후에는 swift UI를 만들어서 해당 모델(MVVM)을 강조함
    상호 관계를 외워도야함.
    view와 model을 끊어지지 않고 서로를 단절함.  직접 단절함 
        -> 이전에도 그렇게 만들려고 했지만, 그렇지 못했기 때문에 해결함.
    mvc는 연관되어 있기 때문에 -> 개별 팀간의 대화 및 소통이 필요함. -> 단절이 높을 수록 일의 작업이 편함

presentation | business logic | data access
       action
view   <----->   ViewModel <-----> model
       blinding            data i/o


MVVM 패턴은 Model-View-ViewModel의 약자로, 소프트웨어 디자인 패턴 중 하나입니다. 
이 패턴은 UI 구현을 단순화하고 테스트 가능한 코드를 작성하기 위해 사용됩니다. MVVM은 다음과 같이 세 가지 주요 계층으로 구성됩니다.


MVVM 패턴의 각 계층 및 상호 작용 설명:

1. View (UI):
   - 사용자 인터페이스를 나타내며 사용자의 입력을 받습니다.
   - UI는 ViewModel을 통해 데이터를 표시하고 사용자의 상호 작용을 ViewModel에 전달합니다.

2. ViewModel:
   - 사용자 인터페이스의 상태와 동작을 관리합니다.
   - View에서 받은 사용자 입력 및 이벤트를 처리하고, Model로부터 필요한 데이터를 가져와서 View에 전달합니다.
   - UI와 비즈니스 로직 간의 중간 계층으로, 사용자 인터페이스와 비즈니스 로직을 분리합니다.
   - View의 상태 변화에 대응하여 데이터 바인딩을 통해 UI 갱신을 수행합니다.

3. Model (Business Logic 및 Data, Network):
   - 비즈니스 로직과 데이터 관리를 담당합니다.
   - Business Logic은 애플리케이션의 핵심 로직을 구현하고, Data 및 Network은 데이터의 입출력을 처리합니다.
   - ViewModel이 필요로 하는 데이터를 제공하고, 데이터 변경을 감지하여 ViewModel에 알립니다.

사용자의 Action들은 View를 통해 들어오게 됩니다.
View에 Action이 들어오면, Command 패턴으로 View Model에 Action을 전달합니다.
View Model은 Model에게 데이터를 요청합니다.
Model은 View Model에게 요청받은 데이터를 응답합니다.
View Model은 응답 받은 데이터를 가공하여 저장합니다.
View는 View Model과 Data Binding하여 화면을 나타냅니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
[12] FFI는 어떤 기능이며, 소프트웨어 개발시 어떤 경우에 활용할 수 있는지 설명합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------


FFI:
1. 서로 다른 언어로 만들어서 -> 통신을 한다
2. 기계어 레벨에서 합치자

FFI는 Foreign Function Interface의 약자로, 프로그래밍 언어 간의 상호 운용성을 제공하는 인터페이스를 나타냅니다. 
FFI를 사용하면 서로 다른 언어로 작성된 코드 간에 함수 호출 및 데이터 교환을 할 수 있습니다. 
주로 다른 언어로 작성된 코드를 현재 언어에서 활용하거나, 반대로 현재 언어로 작성된 코드를 다른 언어에서 사용할 때 활용됩니다.

일반적으로 FFI는 다음과 같은 상황에서 활용됩니다:

1. 라이브러리 통합:
   - 다른 언어로 작성된 라이브러리를 현재 언어에서 사용하고자 할 때 FFI를 활용할 수 있습니다. 
   이는 라이브러리의 기능을 활용하면서도 프로젝트의 일부분을 다른 언어로 작성할 수 있는 유연성을 제공합니다.

2. 성능 최적화:
   - 성능이 중요한 부분을 다른 언어로 작성하여, 네이티브 코드로 실행함으로써 성능을 향상시킬 수 있습니다. 이때 FFI를 사용하여 언어 간의 통합을 수행합니다.

3. 레거시 코드 이용:
   - 레거시 코드가 다른 언어로 작성되었을 경우, FFI를 통해 현재 프로젝트에서 해당 레거시 코드를 활용할 수 있습니다.

4. 플랫폼 종속성 해결:
   - 서로 다른 플랫폼 간에 일부 기능을 공유하거나 특정 플랫폼에 의존하는 코드를 다른 플랫폼에서 대체하고자 할 때 FFI를 사용할 수 있습니다.

5. 외부 라이브러리와의 통합:
   - 외부 라이브러리나 서비스를 다른 언어에서 제공할 때, FFI를 통해 현재 언어의 코드에서 해당 라이브러리나 서비스를 사용할 수 있습니다.

예를 들어, C 언어에서 Python의 C API를 사용하거나, Rust에서 C 언어의 함수를 호출하는 등의 상황이 FFI의 예시입니다. 
FFI를 사용하면 각 언어의 특성을 최대한 활용하면서도 다양한 언어 간의 협업이 가능해집니다. 
다만, 주의해야 할 점은 언어 간의 메모리 관리나 데이터 타입 변환 등의 부분에서 주의가 필요하며, 이를 신중하게 다루어야 합니다.









설계에 대한 가이드 -> 경험을 공유한다.
설계도를 공유한다.
next-step plug-in-play
호출 받는 코드 - 안정화된 코드: 해당 코드를 건들지 말고 이것을 기준으로 진행
sigleton ->  실행하는 객체가 하나
그에 맞는 일반화된 설계방법에 대해서 활용

adaptee pattern: 
    호출당하는 자 adapter
    client는 target을 호출함.
    interface - virtual function
    실제로 호출되는 코드는 adapter의 operation() 코드이다.
    호출하는 화살표 

adaptee pattern(c++만 유효한 방식): 
    호출당하는 자 adapter
    client는 target을 호출함.
    interface - virtual function
    실제로 호출되는 코드는 adapter의 operation() 코드이다.
    adaptee가 adapter의 베이스 클래스이다. 
    부모가 2개인 class이다.
    mixin함수
    BUT : base class는 하나만 넣기로 하는것이 강조됨


app service 와 web의 패턴이 생기게 됨
시험문제에 나올 확률이 높음

clean architecture:

레이어가 3개로 나뉨
presentation layer
business logick layer
data Acess

결국 class간의 상관 관계
state가 바뀌면 보이는 것은 flutter의 역할임

웹서비스
