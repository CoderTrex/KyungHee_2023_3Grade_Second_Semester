2 page: 언어의 발전이 어떻게 되었는지 -> 꼭 알아두기
---------------------------------------------------------------------------------------------------------
3 page: 하드웨어가 알아들을 수 있는 언어가 사람이 알아들을 수 있게 추상화
---------------------------------------------------------------------------------------------------------
8 page: c++ 파일을 컴파일러에 넣으면 obj라는 파일이 생성이 된다. 
        -> .obj 파일은 .cpp 파일의 수만큼 생성됨.
        컴파일러는 2가지로 구성이된다.
            1. preprocessor(전처리기)가 먼저 작동함.
                번역작업전에 뭘 전에 처리할까? 
                -> #은 전처리 연산자 : # 먼저 처리해야한다.
                ex) #include <iostream> 
                    cout << 은 iostream에 구현이 되어 있음.
            2. translator는 이후에 작동함.

        linker:
            필요한 파일과 소스들을 묶어서 연결함.
            번역작업 이후에 여러가지 obj파일들을 하나로 묶음.

ERROR의 종류:
    1. syntax 에러  : 문법에 규칙에 맞지 않게 작성
    2. linking 에러 : cpp파일안에서는 에러가 없지만 linking하는 과정에서 에러가 발생
                        ex) 정의부와 선언부가 다른 에러 -> 찾지 못함.
    3. runtime 에러 : 코드상 링킹상 에러가 전혀 에러가 없음
                        로직 자체의 에러가 존재해. 에러가 발생함.
                        하나하나 확인하면서 디버깅해야 해결됨.
                        설계의 오류
---------------------------------------------------------------------------------------------------------
9 page:
프로그램: 컴파일되어서 실행가능한 바이너리 파일
프로세스: 메모리 위에 올라가고 실행하는데 전혀 무리가 없는 상태가 됨.
            실행 중인 상태를 의미함.
운영체제: 프로세스가 돌아가기 위한 환경
---------------------------------------------------------------------------------------------------------
10 page: (매우 중요함)
3개의 과정이 매우 중요함.

1. system Requirements
2. Analysis
3. Design
4. Code
5. System Test
6. Maintaince
---------------------------------------------------------------------------------------------------------
12page는 넘어가셈
---------------------------------------------------------------------------------------------------------
13~14page:
블랙박스 테스트 vs 화이트 박스 테스트
---------------------------------------------------------------------------------------------------------
15page:
---------------------------------------------------------------------------------------------------------
16page:
namespace -> class의 이름을 가져옴
위상의 개념으로 쪼개 놓은 것이다.

class를 

---------------------------------------------------------------------------------------------------------
19page:

main은 복잡하지 않은 것이 좋음
main은 시작에 있어서 선언되는 시작 지점
C start-up routine이 먼저 실행해서 거기서 main을 부름
stack 맨 꼭데기에 main함수를 실행하기 위한 설정을 맨위에 올림

---------------------------------------------------------------------------------------------------------
22page:

변수: 프로그램이 동작하는 과정에서 임의의 값이 들어갈 수 있는 "메모리 공간" 자체
하나의 로컬내에서는 동일한 이름 불가능

32bit CPU에서 int의 사이즈는 4byte
64bit CPU에서 int의 사이즈는 8byte

float는 정수부가 큼
double은 실수부가 큼

---------------------------------------------------------------------------------------------------------
23~34page:
자료형에 대한 이야기


상수중에 단일 문자상수는 외따옴표
상수중에 문자열 상수는 쌍따옴표

상수는 function call이 발생해야 결정되는 값


---------------------------------------------------------------------------------------------------------
37 page:

int x = 42;
cout.width(5); // 길이가 5칸이므로 공백 3칸에 숫자 2칸
cout << x << '\n'; // Outputs    42
cout << x << '\n'; // Outputs 42 -> 위에 한 번만 적용됨.


int x = 42;
cout << setw(5) << x << '\n'; // Outputs 42 // 함수를 통해서 적용함.
cout << x << '\n'; // Outputs 42


fill(char) 함수는 지정된 범위의 공백을 지정한 문자로 채울 수 있는 기능을 제공
지정된 문자는 재지정을 하기 전까지 계속 적용됨

setfill(char)는 cout 스트림에 입력 파라미터값으로 넣어 fill() 함수와 같은 기능을
수행
37
int x = 42;
cout.width(5);
cout.fill('*'); 빈 공간에 *를 집어 넣음
cout << x << '\n'; // Outputs ***42
int x = 42;
cout << setw(5) << setfill('*') << x << '\n'; // Outputs ***42


진수 표현
int x = 42;
cout << oct << x << '\n'; // Outputs 52
cout << dec << x << '\n'; // Outputs 42
cout << hex << x << '\n'; // Outputs 2A
