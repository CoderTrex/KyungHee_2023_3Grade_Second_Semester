객체지향 프로그래밍이란? : 객체지향 프로그래밍은 객체를 기반으로 하는 프로그래밍이다.
장점: 
    1. 객체는 현실 세계를 모델링하기 때문에 현실 세계의 사물들을 프로그래밍에 반영하기 쉽다.
    2. 객체는 재사용이 가능하기 때문에 코드의 재사용성이 높다. -> 상속을 통해 해당 장점이 구현된다.

단점:
    1. 전통된 프로그래밍 기법보다 개념적으로 어렵다.
        -> 숙련된 프로그래머에게도 어렵다.
    2. 객체지향 프로그램은 성능이 떨어진다.
        -> 현재는 하드웨어의 발전으로 인해 성능이 떨어지는 것은 크게 문제가 되지 않는다.
        -> 이전 C++은 느리기로 유명했음.

객체의 사용이유: 추상화, 캡슐화, 상속, 다형성을 통해서 객체의 사용이유를 알 수 있다.

추상화: 객체의 공통된 특징을 파악해서 하나의 개념으로 다루는 것을 의미한다.
캡슐화: 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.
상속  : 부모 클래스의 속성과 행위를 자식 클래스가 물려받는 것을 의미한다.
다형성: 같은 이름의 함수를 호출하더라도 다른 기능을 수행하도록 하는 것을 의미한다.

대부분의 사람들은 객체의 사용법에 대해서만 관심을 가짐. 이는 현실 세계의 사물을 반영할 수 있는 개념이다.
때문에 기능을 사용하기 쉽게 제공하지만, 안의 내부 동작 및 원리를 감추는(Data Hiding) 객체라는 개념을 사용한다.
또한 분업의 효율성을 높이기 쉬운 방법이기도 하다.

------------------------------------------------------------------------------------------------------------
inline 함수는 함수의 선언과 정의를 같이 하거나또는 명시적으로 inline 키워드를 붙여서 선언하는 함수이다.
장점은 간단하며 한눈에 알아볼 수 있다는 점이다.
단점으로는 자주 많이 호출할 시 binary의 크기가 커지고 재귀함수를 사용할 수 없다는 점이 단점이다.


------------------------------------------------------------------------------------------------------------
복사 생성자 vs 복사 대입 연산자
차이점: 선언 시기와 동시에 대입 연산을 한다면 복사 생성자이며, 선언 이후에 대입 연산을 한다면 복사 대입 연산자이다.
이후 call-by-value를 호출한다면, 복사 생성자가 호출된다.



------------------------------------------------------------------------------------------------------------
다형성이란: 같은 이름을 통해서 다른 기능을 구현하는 것을 의미한다.
동음이의와 비슷한 개념이라고 보면 좋다.
다형성은 오버로딩과 오버라이딩으로 구현된다.

오버로딩이란?
두개 이상의 함수나 연산자를 같은 식별자와 양식으로 재정의하는 행위이다.
함수와 오버로딩은 같은 이름을 가지고 있지만,
매개변수의 개수나 자료형의 차이에 의해 구분되어 다르게 동작한다.

오버로딩의 조건은 다음과 같다.
1. 함수 이름이 같아야한다.
2. 매개변수의 개수 또는 자료형이 달라야한다.
3. 반환형은 오버로딩을 구현하는데 아무런 영향을 주지 않는다.

오버라이딩이란?
상위 클래스의 메소드를 하위 클래스(상속 받은 클래스)에서 재사용하는 것이다.

구분:       오버로딩	                오버라이딩
문 법:      함수 문법	                클래스 문법
함수 명:    같아야 재정의	            부모의 것과 같아야 한다.
인자 타입:  달라야 재정의	            부모의 것과 같아야 한다.
인자 개수:  달라야 재정의	            부모의 것과 같아야 한다.
반환 타입	재정의와 아무 연관 없다.	 부모의 것과 같아야 한다.
목 적:	                함수 재정의와 다형성 


------------------------------------------------------------------------------------------------------------
바인딩이란? : 묶는다는 뜻으로 구성요소들이 확정이되어서 더 이상 값을 변경할 수 없는 상태를 이르는 말을 바인딩이라고 한다.
바인딩은 동적 바인딩과 정적 바인딩으로 구성된다.

정적 바인딩은 컴파일 타임에 결정되는 바인딩으로 상대적으로 빠르며, 컴파일 이후에는 변경이 불가능하다는 성질이 있다.
동적 바인딩은 런타임에 결정되는 바인딩으로 상대적으로 느리지만, 컴파일 이후에 런타임에 상황에 맞춰 변경이 가능해 이식성이 높다.


------------------------------------------------------------------------------------------------------------
가상함수는 오버라이딩을 할 수 있게 해주는 함수로 virtual 키워드를 사용하여 선언한다.
이외의 순수가상함수가 존재하는데 이는 = 0을 가상함수 뒤에 붙여서 사용하는 함수이다.
해당 순수가상함수를 상속받는 클래스는 반드시 해당 함수를 오버라이딩을 해야 한다.

upcasting와 downcasting은 상속 관계에 있는 class끼리의 형변환을 의미한다.
upcasting은 자식클래스를 부모클래스로 캐스팅하는 것으로 static_cast<부모클래스>(자식클래스)를 통해서 형변환이 가능하다.

downcasting은 부모클래스를 자식클래스로 캐스팅하는 것으로 dynamic_cast<자식클래스>(부모클래스)만을 통해서 형변환이 가능하다.
명시적으로는 c++이 downcasting을 허용하지 않는다. 하지만 컴파일에서 확인하지 않는 dynamic_cast를 통해서는 가능하다.


------------------------------------------------------------------------------------------------------------
포함관계와 집합관계

포함관계는 is-a 관계로 상속을 통해서 구현되는 관계이다.
- 포함관계는 상속을 통해서 구현된 관계로 상속한 클래스는 포함한 클래스의 멤버를 가지고 있다.
-> 호출 순서: 부모클래스 생성자 -> 자식클래스 생성자 -> 자식클래스 소멸자 -> 부모클래스 소멸자

집합관계는 has-a 관계로 포함을 통해서 구현되는 관계이다.
- 클래스 내부에 다른 클래스의 객체를 멤버로 가지는 관계이다.
-> 호출 순서: 멤버클래스 생성자 -> 클래스 생성자 -> 클래스 소멸자 -> 멤버클래스 소멸자